#############################################################################
##
#W  grp.gd                      GAP library                     Thomas Breuer
#W                                                             & Frank Celler
#W                                                             & Bettina Eick
#W                                                           & Heiko Theissen
##
#H  @(#)$Id$
##
#Y  Copyright (C)  1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
#Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
##
##  This file contains the declarations of operations for groups.
##

#1
##  Unless explicitly declared otherwise, all subgroup series are descending. 
##  That is they are stored in decreasing order.

#2
##  If a group <U> is created as a subgroup of another group <G>, <G>
##  becomes the parent of <U>. There is no `universal' parent group,
##  parent-child chains can be arbitrary long. {\GAP} stores the result of some
##  operations with the parent like `Normalizer' as an attribute.

Revision.grp_gd :=
    "@(#)$Id$";


GroupString := function(arg) return "Group"; end;
#T !!!

#############################################################################
##
#V  InfoGroup
##
##  is the `InfoClass' for the generic group theoretic functions.
DeclareInfoClass( "InfoGroup" );


#############################################################################
##
#C  IsGroup( <obj> )
##
##  A group is a magma-with-inverses (see~"IsMagmaWithInverses")
##  and associative (see~"IsAssociative") multiplication.
##
DeclareSynonym( "IsGroup", IsMagmaWithInverses and IsAssociative );


#############################################################################
##
#A  GeneratorsOfGroup( <G> )
##
##  returns a list of generators of the group <G>.
##  If <G> has been created by the command `GroupWithGenerators'
##  (see~"GroupWithGenerators"), with argument <gens>, then 
##  the list returned by `GeneratorsOfGroup' will be equal to <gens>.
##
DeclareSynonymAttr( "GeneratorsOfGroup", GeneratorsOfMagmaWithInverses );


#############################################################################
##
#P  IsCyclic( <G> )
##
##  A group is cyclic if it can be generated by one element.
##
DeclareProperty( "IsCyclic", IsGroup );

InstallSubsetMaintenance( IsCyclic, IsGroup and IsCyclic, IsGroup );

InstallFactorMaintenance( IsCyclic,
    IsGroup and IsCyclic, IsCollection, IsGroup );

InstallTrueMethod( IsCyclic, IsGroup and IsTrivial );

InstallTrueMethod( IsCommutative, IsGroup and IsCyclic );


#############################################################################
##
#P  IsElementaryAbelian( <G> )
##
##  A group <G> is elementary abelian if it is commutative and if there is a
##  prime $p$ such that the order of each element in <G> is divisible by $p$.
##
DeclareProperty( "IsElementaryAbelian", IsGroup );

InstallSubsetMaintenance( IsElementaryAbelian,
    IsGroup and IsElementaryAbelian, IsGroup );

InstallFactorMaintenance( IsElementaryAbelian,
    IsGroup and IsElementaryAbelian, IsCollection, IsGroup );

InstallTrueMethod( IsElementaryAbelian, IsGroup and IsTrivial );


#############################################################################
##
#P  IsFinitelyGeneratedGroup( <G> )
##
##  tests whether the group <G> can be generated by a finite number of
##  generators. (This property is mainly used to obtain finiteness
##  conditions.)
##
DeclareProperty( "IsFinitelyGeneratedGroup", IsGroup );

InstallFactorMaintenance( IsFinitelyGeneratedGroup,
    IsGroup and IsFinitelyGeneratedGroup, IsCollection, IsGroup );

InstallTrueMethod( IsFinitelyGeneratedGroup, IsGroup and IsTrivial );


#############################################################################
##
#P  IsSubsetLocallyFiniteGroup(<U>) . . . . test if a group is locally finite
##
##  A group is called locally finite if every finitely generated subgroup is
##  finite. This property checks whether the group <U> is a subset of a
##  locally finite group. This is used to check whether finite generation
##  will imply finiteness, as it does for example for permutation groups.
##
DeclareProperty( "IsSubsetLocallyFiniteGroup", IsGroup );

# this true method will enforce that many groups are finite, which is needed
# implicitly
InstallTrueMethod( IsFinite, IsFinitelyGeneratedGroup and IsGroup
                             and IsSubsetLocallyFiniteGroup );

InstallTrueMethod( IsSubsetLocallyFiniteGroup, IsFinite and IsGroup );

InstallSubsetMaintenance( IsSubsetLocallyFiniteGroup,
    IsGroup and IsSubsetLocallyFiniteGroup, IsGroup );

#3
##  The following filters and operations indicate capabilities of GAP. They
##  can be used in the method selection or algorithms to check whether
##  it is feasible to compute certain operations for a given group. In
##  general, they return `true' if good algorithms for the given arguments
##  exist. An answer `false' indicates that no method for this group exists,
##  or that the existing methods might run into problems.
##
##  Typical examples when this might happen is with finitely presented
##  groups, for which many of the methods cannot be guaranteed to succeed in
##  all situations.
##
##  The willingness of GAP to perform certain operations may change over
##  time, depending which further information is known. Therefore operations
##  with boolean values are not implemented as a property, but as a filter.

#############################################################################
##
#F  CanEasilyTestMembership( <grp> )
##
##  This filter indicates whether a group can test membership of
##  elements in <grp> (via the operation `in') in reasonable time.
##  It is used by the method selection to decide whether an algorithm
##  that relies on membership tests may be used.
##
DeclareFilter( "CanEasilyTestMembership" );

#############################################################################
##
#F  CanComputeSize( <grp> )
##
##  This filter indicates whether the size of the group <grp> (which might
##  be `infinity') can be computed.
DeclareFilter( "CanComputeSize" );

#############################################################################
##
#F  CanComputeIndex( <G>, <H> )
##
##  This filter indicates whether the index $[G:H]$ (which might
##  be `infinity') can be computed. It assumes that $H\le G$. (see
##  "CanComputeIsSubset")
DeclareOperation( "CanComputeIndex", [IsGroup,IsGroup] );

#############################################################################
##
#F  CanComputeIsSubset( <G>, <H> )
##
##  This filter indicates that {\GAP} can test (via `IsSubset') whether <H>
##  is a subgroup of <G>.
DeclareOperation( "CanComputeIsSubset", [IsDomain,IsDomain] );

#############################################################################
##
#P  KnowsHowToDecompose( <G> )
#O  KnowsHowToDecompose( <G>, <gens> )
##
##  Tests whether the group <G> can decompose elements in the generators
##  <gens>. If <gens> is not given it tests, whether it can decompose in the
##  generators given in `GeneratorsOfGroup'.
##
##  This property can be used for example to check whether a
##  `GroupHomomorphismByImages' can be reasonably defined from this group.
DeclareProperty( "KnowsHowToDecompose", IsGroup );
DeclareOperation( "KnowsHowToDecompose", [ IsGroup, IsList ] );

#############################################################################
##
#P  IsPGroup( <G> ) . . . . . . . . . . . . . . . . .  is a group a p-group ?
##
##  <G> is a $p$-group if $|G|=p^n$ for a prime $p$.
DeclareProperty( "IsPGroup", IsGroup );


#############################################################################
##
#A  PrimePGroup( <G> )
##
##  If <G> is a $p$-group of order $p^n$, this attribute holds the prime
##  number $p$. An error is issued if <G> is not a $p$-group.
DeclareAttribute( "PrimePGroup", IsPGroup );


#############################################################################
##
#A  PClassPGroup( <G> )
##
DeclareAttribute( "PClassPGroup", IsPGroup );


#############################################################################
##
#A  RankPGroup( <G> )
##
DeclareAttribute( "RankPGroup", IsPGroup );


#############################################################################
##
#P  IsNilpotentGroup( <G> )
##
##  A group is nilpotent if the lower central series
##  (see~"LowerCentralSeriesOfGroup" for a definition) reaches the trivial
##  subgroup in a finite number of steps.
##
DeclareProperty( "IsNilpotentGroup", IsGroup );

InstallSubsetMaintenance( IsNilpotentGroup,
    IsGroup and IsNilpotentGroup, IsGroup );

InstallFactorMaintenance( IsNilpotentGroup,
    IsGroup and IsNilpotentGroup, IsCollection, IsGroup );

InstallTrueMethod( IsNilpotentGroup, IsGroup and IsCommutative );


#############################################################################
##
#P  IsPerfectGroup( <G> )
##
##  A group is perfect if it equals its derived subgroup.
##
DeclareProperty( "IsPerfectGroup", IsGroup );

InstallFactorMaintenance( IsPerfectGroup,
    IsGroup and IsPerfectGroup, IsCollection, IsGroup );


#############################################################################
##
#P  IsSimpleGroup( <G> )
##
##  A group is simple, if it has no nontrivial normal subgroups.
##
DeclareProperty( "IsSimpleGroup", IsGroup );

InstallIsomorphismMaintenance( IsSimpleGroup,
    IsGroup and IsSimpleGroup, IsGroup );


#############################################################################
##
#P  IsSupersolvableGroup( <G> )
##
##  a finite group is supersolvable if it has a normal series with cyclic
##  factors.
##
DeclareProperty( "IsSupersolvableGroup", IsGroup );

InstallSubsetMaintenance( IsSupersolvableGroup,
    IsGroup and IsSupersolvableGroup, IsGroup );

InstallFactorMaintenance( IsSupersolvableGroup,
    IsGroup and IsSupersolvableGroup, IsCollection, IsGroup );

InstallTrueMethod( IsSupersolvableGroup, IsNilpotentGroup );


#############################################################################
##
#P  IsMonomialGroup( <G> )
##
##  A finite group is monomial if every irreducible complex character is
##  induced from a linear character of a subgroup.
##
DeclareProperty( "IsMonomialGroup", IsGroup );

InstallFactorMaintenance( IsMonomialGroup,
    IsGroup and IsMonomialGroup, IsCollection, IsGroup );

InstallTrueMethod( IsMonomialGroup, IsSupersolvableGroup and IsFinite );


#############################################################################
##
#P  IsSolvableGroup( <G> )
##
##  A group is solvable if the derived series (see"DerivedSeriesOfGroup" for
##  a definition) reaches the trivial subgroup in a finite number of steps.
##
##  For finite groups this is the same as being polycyclic.
##
DeclareProperty( "IsSolvableGroup", IsGroup );

InstallSubsetMaintenance( IsSolvableGroup,
    IsGroup and IsSolvableGroup, IsGroup );

InstallFactorMaintenance( IsSolvableGroup,
    IsGroup and IsSolvableGroup, IsCollection, IsGroup );

InstallTrueMethod( IsSolvableGroup, IsMonomialGroup );
InstallTrueMethod( IsSolvableGroup, IsSupersolvableGroup );

#############################################################################
##
#P  IsPolycyclicGroup( <G> )
##
##  A group is polycyclic if it has a subnormal series with cyclic factors.
##  For finite groups this is the same as if the group is solvable.
##
DeclareProperty( "IsPolycyclicGroup", IsGroup );
InstallTrueMethod( IsPolycyclicGroup,IsSolvableGroup and IsFinite);


#############################################################################
##
#A  AbelianInvariants( <G> )
##
##  Computes the abelian invariants of the commutator factor group of <G>.
##  They are given as a list of the orders of a set of independent
##  generators of $G/G'$ (see "IndependentGeneratorsOfAbelianGroup").
##  
DeclareAttribute( "AbelianInvariants", IsGroup );


#############################################################################
##
#A  AsGroup( <D> )  . . . . . . . . . . . . . collection <D>, viewed as group
##
##  if the elements of the collection <D> form a group the command returns
##  this group, otherwise it returns `fail'.
##
DeclareAttribute( "AsGroup", IsCollection );


#############################################################################
##
#A  ChiefSeries( <G> )
##
##  A series of normal subgroups of <G> which cannot be refined further.
##  That is there is no normal subgroup <N> of <G> with $U_{i+1}\< N\< U_i$.
##  This attribute returns *one* chief series (of potentially many
##  possibilities).
##
DeclareAttribute( "ChiefSeries", IsGroup );


#############################################################################
##
#O  ChiefSeriesUnderAction( <H>, <G> )
##
##  returns a series of normal subgroups of <G> which are invariant under
##  <H> such that the series cannot be refined any further. <G> must be s
##  a subgroup of <H>.
##  This attribute returns *one* such series (of potentially many
##  possibilities).
##
DeclareOperation( "ChiefSeriesUnderAction", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  ChiefSeriesThrough( <G>, <list> )
##
##  is a chief series of the group <G> going through the normal subgroups in
##  <l>. <l> must be a list of normal subgroups of <G> contained in each
##  other, sorted by descending size.
##  This attribute returns *one* chief series (of potentially many
##  possibilities).
##
DeclareOperation( "ChiefSeriesThrough", [ IsGroup, IsList ] );


#############################################################################
##
#A  CommutatorFactorGroup( <G> )
##
##  computes the commutator factor group $<G>/<G>^{\prime}$ of the group <G>.
##
DeclareAttribute( "CommutatorFactorGroup", IsGroup );


#############################################################################
##
#A  CompositionSeries( <G> )
##
##  A composition series is a subnormal series which cannot be refined.
##  This attribute returns *one* composition series (of potentially many
##  possibilities).
##
DeclareAttribute( "CompositionSeries", IsGroup );
#T and for module?

#############################################################################
##
#F  DisplayCompositionSeries( <G> )
##
##  Displays a composition series of <G> in a nice way, identifying the
##  simple factors.
##
DeclareGlobalFunction( "DisplayCompositionSeries" );


#############################################################################
##
#A  ConjugacyClasses( <G> )
##
##  returns the conjugacy classes of elements of <G> as a list of
##  `ConjugacyClass'es of <G> (see~`ConjugacyClass'
##  ("ConjugacyClass") for details). It is guaranteed that the class of the
##  identity is in the first position, the further arrangement depends on
##  the method chosen (and might be different for equal but not identical
##  groups).
##
DeclareAttribute( "ConjugacyClasses", IsGroup );


#############################################################################
##
#A  ConjugacyClassesMaximalSubgroups( <G> )
##
##  returns the conjugacy classes of maximal subgroups of <G>.
##  Representatives of the classes can be computed directly by
##  `MaximalSubgroupClassReps' (see "MaximalSubgroupClassReps").
##
DeclareAttribute( "ConjugacyClassesMaximalSubgroups", IsGroup );


#############################################################################
##
#A  MaximalSubgroups( <G> )
##
##  returns a list of all maximal subgroups of <G>. This may take up much
##  space, therefore the command should be avoided if possible. See
##  "ConjugacyClassesMaximalSubgroups".
##
DeclareAttribute( "MaximalSubgroups", IsGroup );


#############################################################################
##
#A  MaximalSubgroupClassReps( <G> )
##
##  returns a list of conjugacy representatives of the maximal subgroups
##  of <G>.
##
DeclareAttribute("MaximalSubgroupClassReps",IsGroup);


#############################################################################
##
#A  PerfectResiduum( <G> )
##
##  is the smallest normal subgroup of <G> that has a solvable factor group.
##
DeclareAttribute( "PerfectResiduum", IsGroup );


#############################################################################
##
#A  RepresentativesPerfectSubgroups( <G> )
##
##  returns a list of conjugacy representatives of perfect subgroups of <G>.
##  This uses the library of perfect groups (see "PerfectGroup"), thus it
##  will issue an error if the library data is insufficient to determine all
##  perfect subgroups.
##
DeclareAttribute( "RepresentativesPerfectSubgroups", IsGroup );


#############################################################################
##
#A  ConjugacyClassesPerfectSubgroups( <G> )
##
##  returns a list of the conjugacy classes of perfect subgroups of <G>.
##  (see "RepresentativesPerfectSubgroups".)
##
DeclareAttribute( "ConjugacyClassesPerfectSubgroups", IsGroup );


#############################################################################
##
#A  ConjugacyClassesSubgroups( <G> )
##
##  This attribute returns the list of conjugacy classes of subgroups of the
##  group <G>. It also is applicable for lattices of subgroups (see
##  "LatticeSubgroups").
##
DeclareAttribute( "ConjugacyClassesSubgroups", IsGroup );


#############################################################################
##
#A  LatticeSubgroups( <G> )
##
##  computes the lattice of conjugacy classes of subgroups of the group <G>.
##  This lattice has the conjugacy classes of subgroups as an attribute (see
##  "ConjugacyClassesSubgroups") and permits one to test
##  maximality/minimality relations.
##
DeclareAttribute( "LatticeSubgroups", IsGroup );

#############################################################################
##
#A  DerivedLength( <G> )
##
##  The derived length of a group is the number of steps in the derived
##  series. (As there is always the group, it is the series length minus 1.)
##
DeclareAttribute( "DerivedLength", IsGroup );


#############################################################################
##
#A  DerivedSeriesOfGroup( <G> )
##
##  The derived series of a group is obtained by $U_{i+1}=U_i'$. It stops 
##  if $U_i$ is perfect.
##
DeclareAttribute( "DerivedSeriesOfGroup", IsGroup );


#############################################################################
##
#A  DerivedSubgroup( <G> )
##
##  The derived subgroup $G'$ of $G$ is the subgroup generated by all
##  commutators of elements of $G$. It is normal in $G$ and the factor
##  $G/G'$ is the largest abelian factor of $G$.
##
DeclareAttribute( "DerivedSubgroup", IsGroup );


#############################################################################
##
#A  DimensionsLoewyFactors( <G> )
##
DeclareAttribute( "DimensionsLoewyFactors", IsGroup );


#############################################################################
##
#A  ElementaryAbelianSeries( <G> )
##
##  returns a series of normal subgroups of $G$ such that all factors are
##  elementary abelian. If the group is not solvable (and thus no such series
##  exists) it returns `fail'.
##
DeclareAttribute( "ElementaryAbelianSeries", IsGroup );


#############################################################################
##
#A  Exponent( <G> )
##
##  The exponent $e$ of a group <G> is the lcm of the orders of its
##  elements, that is $e$ is the smallest integer such that $g^e=1$ for all
##  $g\in G$
##
DeclareAttribute( "Exponent", IsGroup );


#############################################################################
##
#A  FittingSubgroup( <G> )
##
##  The Fitting subgroup of a group <G> is its largest nilpotent normal
##  subgroup.
##
DeclareAttribute( "FittingSubgroup", IsGroup );


#############################################################################
##
#A  PrefrattiniSubgroup( <G> )
##
##  returns a Prefrattini subgroup of the finite solvable group <G>.
##  A factor $M/N$ of $G$ is called a Frattini factor if $M/N \leq
##  \phi(G/N)$ holds.  The group $P$ is a Prefrattini subgroup of $G$ if $P$
##  covers each Frattini chief factor  of $G$, and  if for each  maximal
##  subgroup  of $G$ there exists a conjugate maximal subgroup, which
##  contains $P$.   In a finite solvable group $G$ the Prefrattini subgroups
##  form a characteristic conjugacy class of subgroups and the intersection
##  of all these subgroups is the Frattini subgroup of $G$.
##
DeclareAttribute( "PrefrattiniSubgroup", IsGroup );


#############################################################################
##
#A  FrattiniSubgroup( <G> )
##
##  The Frattini subgroup of a group <G> is the intersection of all maximal
##  subgroups of <G>.
##
DeclareAttribute( "FrattiniSubgroup", IsGroup );


#############################################################################
##
#A  InvariantForm( <D> )
##
DeclareAttribute( "InvariantForm", IsGroup );


#############################################################################
##
#A  JenningsSeries( <G> )
##
##  For a $p$-group <G>, this function returns its Jennings series.
##  This series is defined by setting
##  $G_1=G$ and for $i\geq 0$, $G_{i+1}=[G_i,G]G_j^p$, where $j$ is the
##  smallest integer $\geq i/p$. 
##
DeclareAttribute( "JenningsSeries", IsGroup );


#############################################################################
##
#A  LowerCentralSeriesOfGroup( <G> )
##
##  The lower central series of a group <G> is defined as $U_{i+1}:=[G,U_i]$.
##  It is a central series of normal subgroups.
##  The name derives from the fact that $U_i$ is contained in the $i$-th
##  step subgroup of any central series.
##
DeclareAttribute( "LowerCentralSeriesOfGroup", IsGroup );


#############################################################################
##
#A  MaximalNormalSubgroups( <G> )
##
DeclareAttribute( "MaximalNormalSubgroups", IsGroup );


#############################################################################
##
#A  NormalMaximalSubgroups( <G> )
##
DeclareAttribute( "NormalMaximalSubgroups", IsGroup );


#############################################################################
##
#A  NormalSubgroups( <G> )
##
##  returns a list of all normal subgroups of <G>.
##
DeclareAttribute( "NormalSubgroups", IsGroup );


#############################################################################
##
#F  NormalSubgroupsAbove( <G> )
##
DeclareGlobalFunction("NormalSubgroupsAbove");


############################################################################
##
#A  NrConjugacyClasses( <G> )
##
##  returns the number of conjugacy classes of <G>.
##
DeclareAttribute( "NrConjugacyClasses", IsGroup );


#############################################################################
##
#F  Omega( <G>, <p>[, <n>] )
##
##  For a <p>-group <G>, one defines
##  $\Omega_{<n>}(<G>) = \{ g\in <G> \mid g^{<p>^{<n>}} = 1 \}$.
##
##  At the moment methods exist only for abelian <G> and <n>=1.
DeclareGlobalFunction( "Omega" );
DeclareOperation( "OmegaOp", [ IsGroup, IsPosInt, IsPosInt ] );
DeclareAttribute( "ComputedOmegas", IsGroup, "mutable" );


#############################################################################
##
#F  Agemo( <G>, <p>[, <n>] )
##
##  For a <p>-group <G>, one defines
##  $\mho_{<n>}(G) = \langle g^{<p>^{<n>}} \mid g\in <G> \rangle$.
##
DeclareGlobalFunction( "Agemo" );
DeclareOperation( "AgemoOp", [ IsGroup, IsPosInt, IsPosInt ] );
DeclareAttribute( "ComputedAgemos", IsGroup, "mutable" );


#############################################################################
##
#A  RadicalGroup( <G> )
##
##  is the radical of <G>, i.e., the largest normal solvable subgroup of <G>.
##
DeclareAttribute( "RadicalGroup", IsGroup );


#############################################################################
##
#A  RationalClasses( <G> )
##
##  returns a list of the rational classes of the group <G>. (See
##  "RationalClass".)
##
DeclareAttribute( "RationalClasses", IsGroup );


#############################################################################
##
#A  GeneratorsSmallest( <G> )
##
##  returns a ``smallest'' generating set for the group <G>. This is the
##  lexicographically (using {\GAP}s order of group elements) smallest list
##  $l$ of elements of <G> such that $G=\langle l\rangle$ and
##  $l_i\not\in\langle l_1,\ldots,l_{i-1}\rangle$ and $1\not\in l$.  The
##  comparison of two groups via lexicographic comparison of their sorted
##  element lists yields the same relation as lexicographic comparison of
##  their smallest generating sets.
##
DeclareAttribute( "GeneratorsSmallest", IsGroup );


#############################################################################
##
#A  LargestElementGroup( <G> )
##
##  returns the largest element of <G> with respect to the ordering `\<' of
##  the elements family.
##
DeclareAttribute( "LargestElementGroup", IsGroup );


#############################################################################
##
#A  MinimalGeneratingSet( <G> )
##
##  returns a generating set of <G> of minimal possible length.
##
DeclareAttribute( "MinimalGeneratingSet", IsGroup );


#############################################################################
##
#A  SmallGeneratingSet(<G>) small generating set (hopefully even irredundant)
##
##  returns a generating set of <G> which has few elements. As neither
##  irredundancy, nor minimal length is proven it runs much faster than
##  `MinimalGeneratingSet'. It can be used whenever a short generating set is
##  desired which not necessarily needs to be optimal.
##
DeclareAttribute( "SmallGeneratingSet", IsGroup );


#############################################################################
##
#A  SupersolvableResiduum( <G> )
##
##  The supersolvable residuum of a group <G> is its smallest normal
##  subgroup with supersolvable factor group.
##
DeclareAttribute( "SupersolvableResiduum", IsGroup );


#############################################################################
##
#F  SupersolvableResiduumDefault( <G> ) . . . . supersolvable residuum of <G>
##
##  `SupersolvableResiduumDefault' returns a record with components
##  \beginitems
##  `ssr': &
##      the supersolvable residuum of the group <G>, that is,
##      the largest normal subgroup of <G> with supersolvable factor group,
##
##  `ds': &
##      a chain of normal subgroups of <G>,
##      descending from <G> to the supersolvable residuum,
##      such that any refinement of this chain is a normal series.
##  \enditems
##
DeclareGlobalFunction( "SupersolvableResiduumDefault" );


#############################################################################
##
#A  ComplementSystem( <G> )
##
##  A complement system of a group <G> is a set of Hall-$p'$-subgroups of
##  <G>. Every pair of subgroups from this set commutes as subgroups.
##  Complement systems exist only for solvable groups, therefore
##  `ComplementSystem' returns `fail' if the group <G> is not solvable.
##
DeclareAttribute( "ComplementSystem", IsGroup );

#############################################################################
##
#A  SylowSystem( <G> )
##
##  A Sylow system of a group <G> is a set of Sylow subgroups of <G> such
##  that every pair of Sylow subgroups from this set commutes as subgroups.
##  Sylow systems exist only for solvable groups. The operation returns
##  `fail' if the group <G> is not solvable.
##
DeclareAttribute( "SylowSystem", IsGroup );


#############################################################################
##
#A  HallSystem( <G> )
##
##  returns a list of Hall-$\pi$ subgroups for all sets $\pi$ of primes
##  which occur in the order of <G>.
##  Hall systems exist only for solvable groups. The operation returns
##  `fail' if the group <G> is not solvable.
##
DeclareAttribute( "HallSystem", IsGroup );


#############################################################################
##
#A  TrivialSubgroup( <G> ) . . . . . . . . . .  trivial subgroup of group <G>
##
DeclareSynonymAttr( "TrivialSubgroup", TrivialSubmagmaWithOne );


#############################################################################
##
#A  Socle( <G> ) . . . . . . . . . . . . . . . . . . . . . . . . socle of <G>
##
##  The socle is the subgroup generated by all minimal normal subgroups.
##
DeclareAttribute( "Socle", IsGroup );


#############################################################################
##
#A  UpperCentralSeriesOfGroup( <G> )
##
##  The upper central series of a group <G> is defined asan ending series
##  $U_i/U_{i+1}:=Z(G/U_{i+1})$.
##  It is a central series of normal subgroups.
##  The name derives from the fact that $U_i$ contains every $i$-th step
##  subgroup of a central series.
##
DeclareAttribute( "UpperCentralSeriesOfGroup", IsGroup );


#############################################################################
##
#O  EulerianFunction( <G>, <n> )
##
##  returns the  number  of <n>-tuples $(g_1, g_2,  \ldots g_n)$ of elements
##  of the group <G>  that  generate the  whole group <G>.
##  The elements of an <n>-tuple need not be different.  
##
DeclareOperation( "EulerianFunction", [ IsGroup, IsPosInt ] );


#############################################################################
##
#F  AgemoAbove( <G>, <C>, <p> )
##
DeclareGlobalFunction( "AgemoAbove" );


#############################################################################
##
#O  AsSubgroup( <G>, <U> )
##
##  creates a subgroup of <G> which contains the same elements as <U>
##
DeclareOperation( "AsSubgroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  ClassMultiplicationCoefficient( <G>, <i>, <j>, <k> )
#O  ClassMultiplicationCoefficient( <G>, <C_i>, <C_j>, <C_k> )
##
DeclareOperation( "ClassMultiplicationCoefficient",
    [ IsGroup, IsPosInt, IsPosInt, IsPosInt ] );
DeclareOperation( "ClassMultiplicationCoefficient",
    [ IsGroup, IsCollection, IsCollection, IsCollection ] );


#############################################################################
##
#F  ClosureGroupDefault( <G>, <elm> ) . . . . . closure of group with element
##
##  This functions returns the closure of the group <G> with the element
##  <elm>.
##  If <G> has the attribute `AsSSortedList' then also the result has this
##  attribute.
##  This is used to implement the default method for `Enumerator' and
##  `EnumeratorSorted', via the function `EnumeratorOfGroup'.
##
DeclareGlobalFunction( "ClosureGroupDefault" );


#############################################################################
##
#O  ClosureGroup( <G>, <obj> )  . . .  closure of group with element or group
##
##  creates the group generated by the elements of <G> and <obj>.
##  <obj> can be either an element or a collection of elements,
##  in particular another group.
##
DeclareOperation( "ClosureGroup", [ IsGroup, IsObject ] );


#############################################################################
##
#O  ClosureSubgroup( <G>, <obj> )
##
DeclareOperation( "ClosureSubgroup", [ IsGroup and HasParent, IsObject ] );


#############################################################################
##
#O  CommutatorSubgroup( <G>, <H> )
##
##  If <G> and <H> are two subgroups of elements in the same family, this
##  operation returns the subgroup generated by all commutators of elements
##  of <G> and <H>, that is the group
##  $$\left\langle[g,h]=g^{-1}h^{-1}gh\mid g\in G,h\in H\right\rangle$$
DeclareOperation( "CommutatorSubgroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  ConjugateGroup( <G>, <obj> )  . . . . . . conjugate of group <G> by <obj>
##
##  returns the conjugate group of <G>, obtained by applying the conjugating
##  element <obj>.
##  To form a conjugate (group) by any object acting via `^', one can use
##  the infix operator `^'.
##
DeclareOperation( "ConjugateGroup", [ IsGroup, IsObject ] );


#############################################################################
##
#O  ConjugateSubgroup( <G>, <g> )
##
DeclareOperation( "ConjugateSubgroup",
    [ IsGroup and HasParent, IsMultiplicativeElementWithInverse ] );


#############################################################################
##
#O  ConjugateSubgroups( <G>, <U> )
##
##  returns a list of all images of the group <U> under conjugation action
##  by <G>.
##
DeclareOperation( "ConjugateSubgroups", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  Core( <S>, <U> )
##
##  If <S> and <U> are subgroups of elements in the same family, this
##  operation
##  returns the core of <U> in <S>, that is the intersection of all
##  <S>-conjugates of <U>.
##
InParentFOA( "Core", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#O  CosetTable( <G>, <H> )
##
##  returns the coset table of the finitely presented group <G> on the cosets
##  of the subgroup <H>.
##
##  Basically a coset table is the permutation representation of the finitely
##  presented group on the cosets of a subgroup  (which need  not be faithful
##  if the subgroup has a nontrivial  core).  Most  of  the set theoretic and
##  group functions use the regular  representation of <G>, i.e.,  the  coset
##  table of <G> over the trivial subgroup.
##
##  The coset table is returned as a list of lists. For each generator of
##  <G> and its inverse the table contains a generator list. A generator
##  list is simply a list of integers. If <l> is the generator list for the
##  generator <g> and if `<l>[<i>] = <j>' then generator <g> takes the coset
##  <i> to the coset <j> by multiplication from the right. Thus the
##  permutation representation of <G> on the cosets of <H> is obtained by
##  applying `PermList' to each generator list (see "PermList"). The coset
##  table is standardized, i.e., the cosets are sorted with respect to the
##  smallest word that lies in each coset.
##
DeclareOperation( "CosetTable", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  FactorGroup( <G>, <N> )
##
##  returns the image of the `NaturalHomomorphismByNormalSubgroup(<G>,<N>)'.
##
DeclareOperation( "FactorGroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  Index( <G>, <U> )
##
##  returns the index $[G:U]={|G| \over |U|}$.
##
InParentFOA( "Index", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#A  IndexInWholeGroup( <G> )
##
##  If the family of elements of <G> itself forms a group <P>, this
##  attribute returns the index of <G> in <P>.
DeclareAttribute( "IndexInWholeGroup", IsGroup );


#############################################################################
##
#A  IndependentGeneratorsOfAbelianGroup( <A> )
##
##  returns a set of generators <g> of prime-power order of the abelian
##  group <A> such that <A> is the direct product of the cyclic groups
##  generated by the $g_i$.
##
DeclareAttribute( "IndependentGeneratorsOfAbelianGroup",
  IsGroup and IsAbelian );


#############################################################################
##
#O  IsConjugate( <G>, <x>, <y> )
#O  IsConjugate( <G>, <U>, <V> )
##
##  tests whether the elements <x> and <y> or the subgroups <U> and <V> are
##  conjugate under the action of <G>. (They do not need to be contained in
##  <G>.) This command is only a shortcut to
##  `RepresentativeOperation'.
##
DeclareOperation( "IsConjugate", [ IsGroup, IsObject, IsObject ] );


#############################################################################
##
#O  IsNormal( <G>, <U> )
##
##  returns `true' if the group <G> normalizes the group <U>
##  and `false' otherwise.
##
##  A group <G> *normalizes* a group <U> if and only if for every $g \in <G>$
##  and $u \in <U>$ the element $u^g$ is a member of <U>.
##  Note that <U> need not be a subgroup of <G>.
##
InParentFOA( "IsNormal", IsGroup, IsGroup, NewProperty );


#############################################################################
##
#F  IsPNilpotent( <G>, <p> )
##
##  A group is $p$-nilpotent if it possesses a normal $p$-complement.
##
KeyDependentFOA( "IsPNilpotent", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  IsPSolvable( <G>, <p> )
##
##  A group is $p$-solvable if every chief factor is either not divisible
##  by $p$ or solvable.
##
KeyDependentFOA( "IsPSolvable", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  IsSubgroup( <G>, <U> )
##
##  `IsSubgroup' returns `true' if <U> is a group that is a subset of the
##  domain <G>.
##  This is actually checked by calling `IsGroup( <U> )' and
##  `IsSubset( <G>, <U> )';
##  note that special methods for `IsSubset' (see~"IsSubset") are available
##  that test only generators of <U> if <G> is closed under the group 
##  operations.
##  So in most cases,
##  for example whenever one knows already that <U> is a group,
##  it is better to call only `IsSubset'.
##
DeclareGlobalFunction( "IsSubgroup" );


#############################################################################
##
#O  IsSubnormal( <G>, <U> )
##
##  A subgroup <U> of the group <G> is subnormal if it is contained in a
##  subnormal series of <G>.
##
DeclareOperation( "IsSubnormal", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  NormalClosure( <G>, <U> )
##
##  The normal closure of <U> in <G> is the smallest normal subgroup of <G>
##  which contains <U>.
##
InParentFOA( "NormalClosure", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#O  NormalIntersection( <G>, <U> )
##
##  computes the intersection of <G> and <U>, assuming that <G> is normalized
##  by <U>. This works faster than `Intersection', but will not produce the
##  intersection if <G> is not normalized by <U>.
DeclareOperation( "NormalIntersection", [ IsGroup, IsGroup ] );


#############################################################################
##
#O  Normalizer( <G>, <U> )
#O  Normalizer( <G>, <g> )
##
##  Computes the normalizer $N_G(U)$, that is the stabilizer of $U$ under
##  the conjugation action of $G$.
##  The second form computes $N_G(\langle g\rangle)$.
##
InParentFOA( "Normalizer", IsGroup, IsObject, NewAttribute );


#############################################################################
##
#O  CentralizerModulo(<G>,<N>,<elm>)   full preimage of C_(G/N)(elm.N)
##
##  Computes the full preimage of the centralizer $C_{G/N}(elm\cdot N)$ in
##  <G> (without necessarily constructing the factor group).
##
DeclareOperation("CentralizerModulo", [IsGroup,IsGroup,IsObject]);


#############################################################################
##
#F  PCentralSeries( <G>, <p> )
##
KeyDependentFOA( "PCentralSeries", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  PRump( <G>, <p> )
##
##  The *p-rump* of a group $G$ is the subgroup $G' G^p$ for a prime $p$.
##
KeyDependentFOA( "PRump", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  PCore( <G>, <p> )
##
##  The $p$-core of <G> is the largest normal $p$-subgroup of <G>. It is the
##  core of a $p$-Sylow subgroup of <G>.
##
KeyDependentFOA( "PCore", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#O  SubnormalSeries( <G>, <U> )
##
##  If <U> is a subgroup of <G> this operation returns a subnormal series
##  that descend from <G> to a subnormal subgroup <V>$\ge$<U>. If <U> is
##  subnormal, <V>=<U>.
InParentFOA( "SubnormalSeries", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#F  SylowSubgroup( <G>, <p> )
##
##  returns a $p$-Sylow subgroup of the finite group <G>. This is a
##  $p$-subgroup <U> such that the index $[G:U]$ is coprime to $p$.
##  It computes Sylow subgroups via the operation `SylowSubgroupOp'.
##
KeyDependentFOA( "SylowSubgroup", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  SylowComplement( <G>, <p> )
##
##  returns a $p$-Sylow complement of the finite group <G>. This is a
##  subgroup <U> of order coprime to $p$ such that the index $[G:U]$ is a
##  $p$-power.
##
KeyDependentFOA( "SylowComplement", IsGroup, IsPosInt, "prime" );


#############################################################################
##
#F  HallSubgroup( <G>, <pi> )
##
##  computes a $\pi$-Hall subgroup for a set $\pi$ of primes. This is a
##  subgroup which is only divisible by primes in $\pi$ and whose index is
##  coprime to all primes in $\pi$. 
##  A group is solvable if and only if for all sets $\pi$ of primes dividing
##  the group order $\pi$-Hall subgroups exist.
##  The function computes Hall subgroups via the operation `HallSubgroupOp'.
##
KeyDependentFOA( "HallSubgroup", IsGroup, IsList, ReturnTrue );


#############################################################################
##
#O  NrConjugacyClassesInSupergroup( <U>, <G> )
##
DeclareOperation( "NrConjugacyClassesInSupergroup", [ IsGroup, IsGroup ] );


#############################################################################
##
#F  Factorization( <G>, <elm> )
##
##  returns a factorization of <elm> as word in the generators of <G> given in
##  the attribute `GeneratorsOfGroup'. (The corresponding free generators can
##  be obtained via the family of the result.)
##  The algorithm used computes all elements of the group to ensure a short
##  word is found. Therefore this function should *not* be used when the
##  group <G> has more than a few thousand elements. Because of this you
##  also should not call this function within algorithms, but use
##  homomorphisms instead. The sole use of this function is didactic.
DeclareGlobalFunction("Factorization");

#############################################################################
##
#O  GroupByGenerators( <gens> ) . . . . . . . . . . . . . group by generators
#O  GroupByGenerators( <gens>, <id> ) . . . . . . . . . . group by generators
##
##  `GroupByGenerators' returns the group $G$ generated by the list <gens>.
##  If a second argument <id> is present then this is stored as the identity
##  element of the group.
##
##  The value of the attribute `GeneratorsOfGroup' of $G$ need not be equal
##  to <gens>.
##  `GroupByGenerators' is called by `Group'.
##
DeclareOperation( "GroupByGenerators", [ IsCollection ] );
DeclareOperation( "GroupByGenerators",
    [ IsCollection, IsMultiplicativeElementWithInverse ] );


#############################################################################
##
#O  GroupWithGenerators( <gens> ) . . . . . . . . group with given generators
#O  GroupWithGenerators( <gens>, <id> ) . . . . . group with given generators
##
##  `GroupWithGenerators' returns the group $G$ generated by the list <gens>.
##  If a second argument <id> is present then this is stored as the identity
##  element of the group.
##  The value of the attribute `GeneratorsOfGroup' of $G$ is equal to <gens>.
##
DeclareOperation( "GroupWithGenerators", [ IsCollection ] );
DeclareOperation( "GroupWithGenerators",
    [ IsCollection, IsMultiplicativeElementWithInverse ] );


#############################################################################
##
#F  Group( <gen>, ... )
#F  Group( <gens> )
#F  Group( <gens>, <id> )
##
##  `Group( <gen>, ... )' is the group generated by the arguments <gen>, ...
##
##  If the only  argument <gens> is a list  that is not  a matrix then
##  `Group( <gens> )' is the group generated by the elements of that list.
##
##  If there  are two arguments,   a list <gens>  and  an element <id>, then
##  `Group( <gens>, <id> )'  is the group generated  by the elements of
##  <gens>, with identity <id>.
##
##  Note that the value of the attribute `GeneratorsOfGroup' need not be
##  equal to the list <gens> of generators entered as argument.  Use
##  `GroupWithGenerators' if you want to be sure that the argument <gens> is
##  stored as value of `GeneratorsOfGroup'.
##
DeclareGlobalFunction( "Group" );


#############################################################################
##
#F  Subgroup( <G>, <gens> ) . . . . . . . subgroup of <G> generated by <gens>
#F  SubgroupNC( <G>, <gens> )
##
##  creates the subgroup <U> of <G> generated by <gens>. The `Parent' of <U>
##  will be <G>.
##  The `NC' version does not check, whether the elements in <gens> actually lie
##  in <G>.
##
DeclareSynonym( "Subgroup", SubmagmaWithInverses );

DeclareSynonym( "SubgroupNC", SubmagmaWithInversesNC );


#############################################################################
##
#O  RightTransversal( <G>, <U> )
##
##  A right transversal is a list of representatives for the right cosets
##  $U{\setminus}G$ (consisting of cosets $Ug$).
##
##  The object returned by
##  `RightTransversal' is not a plain list, but an object that behaves like an immutable
##  list of length $[<G>{:}<U>]$.
##
##  The operation `PositionCanonical(<t>,<g>)', called for a transveral <t>
##  and an element <g> of <G>, will return the position of the
##  representative in <t> that lies in the same coset of <U> as the element
##  <g> does. (In comparison, `Position' will return `fail' if the element
##  is not equal to the representative.) Functions that implement group
##  actions like `Operation' or `Permutation' (see chapter~"Group
##  Operations") use `PositionCanonical', therefore it is possible to
##  ``act'' on a right transversal to implement the action on the cosets.
##
InParentFOA( "RightTransversal", IsGroup, IsGroup, NewAttribute );


#############################################################################
##
#O  IntermediateSubgroups( <G>, <U> )
##
##  returns a list of all subgroups of <G> that properly contain <U>; that
##  is all subgroups between <G> and <U>. It returns a record with
##  components `subgroups' which is a list of these subgroups as well as a
##  component `inclusions' which lists all maximality inclusions among these
##  subgroups.
##  A maximality inclusion is given as a list `[<i>,<j>]' indicating that
##  subgroup number <i> is a maximal subgroup of subgroup number <j>, the
##  numbers 0 and 1+length(`subgroups') are used to denote <U> and <G>
##  respectively.
##
DeclareOperation( "IntermediateSubgroups", [IsGroup, IsGroup] );

#############################################################################
##
#F  IsomorphismTypeFiniteSimpleGroup( <G> )
##
##  returns a string that describes the isomorphism type of a finite simple
##  group <G>. It returns a record with components `series', `name' and
##  possibly `parameter'. `name' is a string that gives the groups name
##  (possibly several ones). `series' is a string that describes
##  the following series:
##  \beginitems
##  `"A"'&Alternating groups, `parameter' gives the natural degree.
##
##  `"L"'&Linear groups (Chevalley type $A$). `parameter' is a list [<n>,<q>]
##  that indicates $L(n,q)$.
##
##  `"2A"'&Twisted Chevalley type ${}^2A$. `parameter' is a list
##  [<n>,<q>] that indicates ${}^2A(n,q)$.
##
##  `"B"'&Chevalley type $B$. `parameter' is a list
##  [<n>,<q>] that indicates $B(n,q)$.
##
##  `"2B"'&Twisted Chevalley type ${}^2B$. `parameter' is a value
##  <q> that indicates ${}^2B(2,q)$.
##
##  `"C"'&Chevalley type $C$. `parameter' is a list
##  [<n>,<q>] that indicates $C(n,q)$.
##
##  `"D"'&Chevalley type $D$. `parameter' is a list
##  [<n>,<q>] that indicates $D(n,q)$.
##
##  `"2D"'&Twisted Chevalley type ${}^2D$. `parameter' is a list
##  [<n>,<q>] that indicates ${}^2D(n,q)$.
##
##  `"3D"'&Twisted Chevalley type ${}^3D$. `parameter' is a value
##  <q> that indicates ${}^3D(4,q)$.
##
##  `"E"'&Exceptional Chevalley type $E$. `parameter' is a list [<n>,<q>] that
##  indicates $E_n(q)$. The value of <n> is 6,7 or 8.
##
##  `"2E"'&Twisted exceptional Chevalley type $E_6$. `parameter' is a value
##  <q> that indicates ${}^2E_6(q)$.
##
##  `"F"'&Exceptional Chevalley type $F$. `parameter' is a value <q> that
##  indicates $F(4,q)$.
##
##  `"2F"'&Twisted exceptional Chevalley type ${}^2F$, Ree groups.
##  `parameter' is a value <q> that indicates ${}^2F(4,q)$.
##
##  `"G"'&Exceptional Chevalley type $G$. `parameter' is a value <q> that
##  indicates $G(2,q)$.
##
##  `"2G"'&Twisted exceptional Chevalley type ${}^2G$, Ree groups.
##  `parameter' is a value <q> that indicates ${}^2G(2,q)$.
##
##  `"Spor"'&Sporadic groups, `name' gives the name.
##  \enditems
##  If different characterizations are possible only one is given by
##  `series' and `parameter'.
DeclareGlobalFunction( "IsomorphismTypeFiniteSimpleGroup" );


#############################################################################
##
#A  IsomorphismPcGroup( <G> )
##
##  \index{isomorphic!pc group}
##  returns an isomorphism from <G> onto an isomorphic PC group.
##  The series chosen for this PC representation depends on
##  the method chosen.
DeclareAttribute( "IsomorphismPcGroup", IsGroup );

#############################################################################
##
#A  IsomorphismPermGroup(<G>)
##  returns an isomorphism $\varphi$ from <G> onto a permutation group <P>
##  which is isomorphic to <G>. The method will select a suitable
##  permutation representation.
DeclareAttribute("IsomorphismPermGroup",IsGroup);

#############################################################################
##
#A  IsomorphismFpGroup( <G> )
##
##  returns an isomorphism from the given finite group <G> to a finitely
##  presented group isomorphic to <G>. The presentation (and thus the
##  generators in which it is presented) is chosen by a method to obtain a
##  short presentation.
##
DeclareAttribute( "IsomorphismFpGroup", IsGroup );


#############################################################################
##
#A  IsomorphismFpGroupByGenerators( <G>,<gens>[,<string>] )
##
##  returns an isomorphism from a finite group <G> to a finitely presented
##  group <F> isomorphic to <G>.
##  The generators of <F> correspond to the generators of <G> given in
##  the list <gens>.
##  If <string> is given it is used to name the generators of the finitely
##  presented group.
##
DeclareOperation( "IsomorphismFpGroupByGenerators", [ IsGroup, IsList ] );
DeclareOperation( "IsomorphismFpGroupByGenerators",
    [ IsGroup, IsList, IsString ] );

DeclareOperation( 
    "IsomorphismFpGroupBySubnormalSeries", [IsGroup, IsList, IsString] );

DeclareOperation( 
    "IsomorphismFpGroupByCompositionSeries", [IsGroup, IsString] );

DeclareGlobalFunction( "IsomorphismFpGroupByPcgs" );


#############################################################################
##
#A  PrimePowerComponents( <g> )
##
DeclareAttribute( "PrimePowerComponents", IsMultiplicativeElement );


#############################################################################
##
#O  PrimePowerComponent( <g>, <p> )
##
DeclareOperation( "PrimePowerComponent",
    [ IsMultiplicativeElement, IsPosInt ] );


#############################################################################
##
#O  PowerMapOfGroup( <G>, <n>, <ccl> )
##
##  is a list of positions, at position $i$ the position of the conjugacy
##  class containing the <n>-th powers of the elements in the $i$-th class
##  of the list <ccl> of conjugacy classes.
##
DeclareOperation( "PowerMapOfGroup", [ IsGroup, IsInt, IsHomogeneousList ] );


#############################################################################
##
#F  PowerMapOfGroupWithInvariants( <G>, <n>, <ccl>, <invariants> )
##
##  is a list of integers, at position $i$ the position of the conjugacy
##  class containimg the <n>-th powers of elements in class $i$ of <ccl>.
##  The list <invariants> contains all invariants besides element order
##  that shall be used before membership tests.
##
##  Element orders are tested first in any case since they may allow a
##  decision without forming the <n>-th powers of elements.
##
DeclareGlobalFunction( "PowerMapOfGroupWithInvariants" );

#############################################################################
##
#O  HasAbelianFactorGroup(<G>,<N>)
##
##  tests whether $G/N$ is abelian (without explicitly
##  constructing the factor group).
##
DeclareGlobalFunction("HasAbelianFactorGroup");


#############################################################################
##
#O  HasElementaryAbelianFactorGroup(<G>,<N>)
##
##  tests whether $G/N$ is elementary abelian (without explicitly
##  constructing the factor group).
##
DeclareGlobalFunction("HasElementaryAbelianFactorGroup");


#############################################################################
##
#F  IsGroupOfFamily(<G>)
##
##  This filter indicates that the group <G> is the group which is stored in
##  the family of its elements as `WholeGroup'.
##
DeclareFilter("IsGroupOfFamily");


#############################################################################
##

#E
##

