\Chapter{Intro}

This chapter describes the new concepts in {\GAP}4.
These new ideas were
motivated by the developent of computational group theory during the last
years:
On the one hand, algorithms become more and more complex. Functions like
`SylowSubgroup' that were originally called just by the user now become
a small part of an intricate algorithm. Therefore {\GAP} may not assume any
longer that the user himself will take an intelligent choice from the
available methods to solve his task. Thus {\GAP} itself has to take decisions
-- at least not too ignorant ones.

On the other hand, algorithms have to solve partial problems in other
algebraic structures more and more frequently. For example an algorithm for
permutation groups may have to deal with modules and the particular problem
is probably best solved in terms of lattices. Thus {\GAP} has to be extendable
to allow the introduction of such new structures.
(andere benutzer wollen auch strukturen?)

So the new concepts try to fulfill two aims:

{\GAP} should be less ``stupid''. It should not ignore knowledge it has about
objects but use this knowledge for further computations. For example if a
group is known to be nilpotent the $p$-Sylow subgroup can be obtained simply
from the $p$-parts of the groups generators.

On the other side it should be possible to add new algebraic structures to
{\GAP}. This requires the ability to add new categories (e.g. modules), new
representations for existing categories and domains (e.g. monomial matrices)
and new methods to {\GAP}.

We pursued these aims already two years ago. (They are mentioned already in
the old application.) But it took us more time than expected to find the
necessary concepts that made it possible to reach these goals.

The problem had been to make the concepts powerful enough to represent the
complex and intricate relations that may exist between mathematical objects
while keeping them simple enough to implement and apply them. In the words
of Albert Einstein: ``Make everything as simple as possible, but not more
simple''.

The wish to keep {\GAP} 4 compatible to {\GAP} 3 as far as possible did not make
this task easier either.

We finally introduced two essentially new concepts:

First, a significantly extended concept of types. It distinguishes what can
be done with an object, how the object is represented and what its relations
to other objects are. Additionally, the type contains information about the
knowledge one has about the object.

Secondly, a vastly extended scheme for the selection of methods.
It permits to select a
method for an operation based on the differnt parts of the types of all the
arguments (or operands).

We have implemented these concepts in {\GAP} 4. In this implementation, each
operation recalls
the argument types that occur most frequently and the method used for
them. (STIMMT DAS NOCH?)  If the operation is called again with arguments of
the same types, the needed method can be found quickly in the ``cache''.
In effect, the method selection in {\GAP} 4 is faster than in {\GAP} 3.

In the sequel we shall first state the aims more explicit (see "Aims").
Afterwards we describe the type concept (see "The Type Concept"). Then
the method selection ("Methods"). Finally we compare the
concepts to related concepts in other programming languages ("andere").

To ease the understanding of the remaining text the most important terms
will be introduced here already:

The objects that {\GAP} deals with (like the number 13, the list $[1,2]$ or a
matrix) are called {\bf objects}. Two objects that are the same (in the
sense of {\GAP} s = operation) represent the same {\bf element}. In other
words, elements are equivalence classes with respect to `='. Those objects
that represent structured sets are called {\bf domains} (for example the
group $S_{12}$ or a conjugacy class therein).

An *operation* behaves like a function, that is it gets called with
arguments and returns a result (like `Intersection(<arg1>,<arg2>)'
or `<op1>\*<op2>'). In
fact, however it consists of a multitude of functions which are called its
*methods*. Depending on the arguments a method is selected and gets
called.

The {\bf type} of an object represents the aspects which are important for
the method selection. It consists of several parts which could be imagined
as subsets of the set of all objects. The {\bf family} of an object
determines in which relation an object is to other objects (for example all
sets whose elements are permutations are a family). The {\bf categories} of
an object describe what can be done with an object (for example all monoids
are a category). The {\bf representation} of an object determines how the
object is stored in memory (for example all ``dense'' univariate polynomials
are of the same representation). Finally the type contains which attributes
or properties are known for the object and which values the properties have.

\Section{Aims}

Before describing the implementation of these new concepts in {\GAP} let us
look more closely on the aims:

\){{\rm Knowledge}}

The first aim is to have the possibility of using knowledge for further
computations. Another way of phrasing would be to make {\GAP} less ignorant.

For example there is a method (due to Baum and Clausen) for computing the
character table of a supersoluble group. This method applies to any
supersoluble group and is substantially faster than the standard method (due
to Dixon and Schneider) which is applicable to any group. If {\GAP} knows that
a group is supersoluble it should use this special method and not ignore the
knowledge it has already.

It should be emphasized that this may be {\bf obtained} knowledge. The
objective is to utilize all knowledge currently available about the relevant
objects and not only the knowledge that was known when the objects were
created.

Usually this means to consider properties (like `IsSolvable'). The
knowledge of attributes (like `Size') itself however is also a property
that can be useful for certain methods.

Finally, of course, the representation of an object may be utilized. (But 
as it is known when generating the object, this has been possible already in
{\GAP} 3).

Additionally {\GAP} should be able to draw simple conclusions. For example that
every cyclic group is abelian.

Or, to give a more complex example: Suppose we have created a permutation
group and have confirmed that it is nilpotent. Then the group is solvable as
well and so for computing the conjugacy classes a special method for
solvable groups is used.

It has not been our aim, however, to make {\GAP} ``intelligent''. That is, when
being asked for the character table of a group, {\GAP} will not try to check
first, whether it is supersoluble. The reason for this is that we have no
idea how to make the system decide which tests are worthwile and which are
not. It is possible, however, to enforce these tests for special methods
for which the potential gain in speed is that big and the test that cheap
in comparison. There are facilities, however, for a method author to enforce
this behaviour for specific methods if the test is deemed to be always
worthwile.

\){{\rm Extendability}}

The other main aim has been to permit extensions to {\GAP} without the need to
change existing code. Additionally, these extensions should embed nicely in
the existing structure. We list a few aspects:
\beginitems
New Categories&Adding Lie Algebras as a subcategory of non-associative
algebras should permit all operations for non-associative algebras to be
applicable to Lie Algebras as well. Of course we will need to add
representations for the new category as well to be able to define objects at
all.

New Representations&When adding new representations it should be
sufficient to write elementary routines to create objects in the new
representation and to allow basic manipulations. For example, for adding
sparse matrices only the new representation and methods to acess the
matrix components need to be implemented.

&Additionally one can add special operations for sparse matrices (like
`'Unsparsify'') or add new methods (like a sparse Gaussian elimination).
These can be added afterwards and don't need to be considered when
creating the new representation.

&It is also possible to specialize an existing representation (for example
monomial matrices as a special case of sparse matrices). Then every method
for sparse matrices is applicable to monomial matrices as well.

New Methods& Besides the methods needed to deal with new
operations, it is possible of course to add methods for existing operations.
For example one could add a new method to compute the character table of a
$p$-group. This method then would be selectable for a group as soon as the
group is known to be a $p$-group.
\enditems

\){{\rm Practicability}}

A main goal in the design finally was practicability. This means:

\beginitems
Usability&
Acessing special methods or new objects should be possible in a similar way
like in {\GAP} 3.

Independence& 
It must be possible to add new code with neither having to change existing
code, nor having to know about existing code. Also it should not be
necessary to basically copy code several times to add new functionality.

Reliability&
Any additions to the system should require no changes in existing code. They
also should affect only those parts of the system they directly interact
with (for example, installing a test for the nilpotence of a matrix group
should not change the behaviour of the Lie algebra routines unless they
require this test implicitely).

Efficency&
The system performance should not be diminuished by the availability of the
new features. This implies that the method selection has to be done quickly.
We are using method caching for the operations here.

There also is the possibility to replace library methods by handwritten C
code. Finally, a compiler that converts {\GAP} code into linkable C-Code is
available.

Implementability&
We had to be able to implement these features in a system. Our
research is in algorithms for group theory and not in the design or
implementation of programming languages.

\enditems

\Chapter{Problems in older versions}

{\GAP} 3 already had some of the features we desired, but there were a
couple of problems with them that led us to designing a new scheme.

\Section{Operation records}
The mechanism used in {\GAP} 3 to permit to select methods depending on
types has been operation records. Every object (which
is represented by a record) contains a component 'operation'. This
component is again a record, whose components are the actual functions which
are to be applied to the object. A dispatcher routine like 'Size' then
just called 'A.operations.Size(A)' to run the applicable method and
returned the result.

Inheritance simply works by copying of operation records. For example
'GroupOps' inherits from 'DomainOps', it overwrites some methods
(like 'Elements' which replaces an error call with a simple orbit
algorithm) and adds some new (like 'Centralizer') which are restricted
to groups.\par
Additionally to calling the routine from the operations record, dispatchers
might perform two additional tasks: The first is checking of the arguments
for applicability (like whether elements really lie in a group). The second
is storing results which are properties of the object in the object and
checking before calling the real routine whether the result is already
stored in the object.

Over the years we have learned about many difficulties with the scheme
described above. The first is the inability to cope well with multiple
arguments for which dispatching should be possible. Typical examples are
arithmetic operations. For these, the dispatcher (in the kernel) usually
dispatched after the first argument. While this works for homogeneous
situations, it becomes difficult if objects of different types are to
operated with: The routine of the left object has to know how to cope with
the right argument, that is it has to know about all possible types of the
right argument.

This becomes increasingly complicated if users implement new objects: If
they want to allow arithmetic operations with existing objects (this came
up for example when
adding algebraic extensions whose elements also should be multipliable with
polynomials), the arithmetic routines for these objects (which are probably
written by someone else, probably in the standard library and in the worst
case in the kernel) have to be changed.

The second disadvantage are problems in using different properties of an
object: The different operations form a pure tree. In some cases (like
homomorphisms from one type of group to another), however, one would like to
join different branches again at a lower point.

This can sometimes be solved by introducing new operation records.
Unfortunately, inheritance is purely linear and no provisions for
merging operation records (and probably even selecting the right routines in
each case) are provided.

A side effect of this (as well as of the first difficulty) are large numbers
of case distinctions in certain routines (like the polynomial multiplication
routines). These case distinctions are difficult to service and have been a
continuous source of nasty problems.

The third problem is mainly of administratorial nature but became almost
insolvable in some situations: The inheritance by copying not only means
that the parent classes operations have to be known to {\GAP} (so reading in
library files has to happen in the right order) but also that additions that
happen after the inheritance do not find their way to the child. This has led
to problems for example with 'SymmetricGroupOps'.

\Section{Sets that may be none}

{\GAP} represents sets by sorted lists. But if the objects in the list can
be changed, the list may suddenly be no set any longer

\beginexample
gap> l:=Set([[1,3],[3,2]]);
[ [ 1, 3 ], [ 3, 2 ] ]
gap> l[2][1]:=1;
1
gap> l=Set(l);  
false
\endexample

Of course, changing an entries entry may happen somewhere else, without the
list ever noting ist. The consequence of this behaviour is, that a list,
that contains composed objects may never store the fact that it is a set.
Each time, it is asked for this property, it has to be tested anew, whether
it is sorted.

If we actually want to keep composed objects in a set, however, to check
for example whether an object is already known, we don't gain anything from
using a ''set'' data type. Even worse: Instead of gaining from a binary
search, whenever we add an element to the set, we additionally test whether
it remained sorted.

In {\GAP} 3 this lead to substantial problems with the orbit algorithm on
vectors. The orbit algorithm keeps a set of all points it has encountered so
far. Vectors however are represented by lists, so they are composed objects.
Consequentially, the ''set'' used for testing is none. (Of course a
user could actually have provided a function for the action that
-- as a side effect -- would change existing vectors entries. So there is no
way around this problem.)

The remedy in {\GAP} 4 for problems of this type is the possibility to
''lock'' objects. By making an composed object *immutable*, one disallows
changes in its components (see "Mutability"). Lists of immutable objects
then may store a flag that they are sorted -- and thus a set -- as no
side-effects may take place.


\danger
User of other systems should note that domains
are simply objects and not a part of the typing system as for example in
Axiom.


\danger
Internally, {\GAP} carries internal bit lists (different to `Blist's) to
indicate categories, representations and so on. A filter is an interface to
these bit lists.


\danger
But you main install special methods for these operations that cross
families.


\danger
\label{storeinfamily}
Families themselves are component objects. They are usually the place where
to store
information needed for operations on its elements. For example the
presentation of a finitely presented group will be stored in its elements
family to permit access for the equality test.

\danger
As families are objects themselves, they also have a kind and a family.
These are the `FamilyOfFamilies' and the `KindOfFamilies'.


\danger
Whenever an object is created, the categories to which the object belongs
have to be declared. However the family might imply further categories (and
these do not need to be declared explicitely when creating the object).
For example any
group of permutations belongs implicitely to the category `PermutationSets'.


With these categories and properties, we can declare vector spaces as
follows:

IsFieldNonExtLSet = \\
\ \ AdditiveMagmaWithInverses \& \\
\ \ nMagmaWithInversesAndZero \& IsAssociative \& IsCommutative

VectorSpace = \\
\ \ AdditiveMagmaWithInverses \& \\
\ \ ExtLSet \& IsExtLDistributive \& IsExtLUnital \& IsExtLAssocicative \& \\
\ \ IsExtLField


\danger
The function `Length' will not work for positional objects. The function
`RecNames' will not work for component objects. There is, however, a
function `REC_NAMES_ROBJ' that will provide the components of an component
objects for debugging purposes.


\danger
An object may change its representation during runtime. In general this is
only useful for mutable objects and should be used with great care.


\danger
Representations are created while the library code is read in. During runtime,
no further categories will be created.


\danger
Categories and Representations are both filters and thus cannot be easily
distinguished. They are conceptually different but implemented by the same
means.

At this point we could explain how objects are actually made. It seems
better didactically, however, to explain first how the method selection
works (you will need this more often anyhow.) If you are curious, have a
glance at section "Kinds and Objects".


\danger
In {\GAP} 3 something slightly similar was accomplished using dispatcher
functions and operation records. But these functions only allowed to
dispatch on one argument and only on information given when the object was
created.

Usually all operation declarations will be read first and all methods
installed afterwards. This permits an method to call other operations, as
all operations are known when the method is installed. To acchieve something
similar for ordinary functions, there is the command


\danger
An object may also claim that it knows an attribute if computation of this
attribute would be very easy. A vector space, for example, may claim that
it knows its size once it knows its dimension and the characteristic of the
underlying field. 


\danger
Attributes are created while the library code is read in. During runtime, no
further attributes will be created.


\danger
This is done by implicitely installing a method, called the *system getter*
for the operation with value `SUM_FLAGS'. This number is some kind on
`'infinity'' for method valuations. Thus, once the attribute is known, this
method will be called. If you design situations, however, in
which objects will claim to posess an attribute while actually still having
to compute it (like in the vector space example above), this would lead to
*your* method (which does the computation) not being called and the system
getter complaining about not finding the attributes value. The solution is 
to install your method with the value `SUM_FLAGS+1' to give it priority
over the system getter.


\danger
The setter in fact is again an operation which has a standard method
installed at value `SUM_FLAGS' which just stores the attribute. You can
install another method that may, for example, immediately store
dependent information. WIE BEKOMMT MAN DAS ATTRIBUT DANN GESPEICHERT?

As each attribute defines an operation, methods can be installed to compute 
the value of this attribute for certain types of objects. Any value returned
by the function will be assigned automatically to the attribute, you don't
need to call the setter.

\danger
Storing all computed attributes for an object may take substantial space. On
the other hand there might be objects that are that unimportant that you
do not want to store attributes for them. Therefore attributes will be
stored only, if the representation of the object is a subrepresentation of
`IsAttributeStoringRep'. KANN DAS POSITIONAL SEIN ?

\danger
Attributes are by standard immutable. In some situations an attribute will
be used, however, to store partial information about an object that may be
completed later. A special case of this are parametrized attributes, where
we don't want to create a new attribute for each value of the parameter.
Sylow subgroups are a good example: We cannot create an atttribute for each
prime number. Instead there is an attribute `ComputedSylowSubgroups' that is
a list, containing in its $i$-th component the $i$-Sylow subgroup (provided
$i$ is a prime). The function `SylowSubgroup' then will access this list and
compute further sylow subgroups if neccessary using the operation
`SylowSubgroupOp'. storing the result again in the list
`ComputedSylowSubgroups'.


\danger
Another aspect of the immutability of attributes is that you usually cannot
change an attribute. Calling the setter later with a different value just
will be ignored.


\danger
It must be pointed out, however, that for the purposes of method selection
the filters that return the value of a property are only fulfilled if the
value of the property is known. In other words, the method selection will
not compute the value of an property just to see whether a method is
applicable. (Such a behaviour would otherwise lead to potentially disastrous
runtime effects.) Doing such things sensibly would require a level of
intelligence which is beyond the scope of a computer program. 

\danger
If you have cases where a certain property is that beneficial that
it is actually worth to force determination of this property, you will have
to install the method without requiring this property, first test in your
function for the value of the property and if this is `false' call
`TryNextMethod()' to retreat gently.

\danger
A variation of this theme is if you have classes of objects for which
a certain attribute can be computed very cheaply. In this case you would not
require `HasPiffle' when installing the method, but add a new property
`IsPiffleObtainable'. All objects in the special class should get this
property implicitly when creating them (either directly in the `Objectify'
command or by a true or immediate method), while an implication would imply
that each object for which `HasPiffle' returns `true' actually would be
`IsPiffleObtainable' as well.

<value> is an integer value given to this function. This value determines
`'how well'' the method performs. Unless you want to acchieve a special
effect this will be 0.

How do all these arguments interlink with each other:

If an operation gets called, {\GAP} first selects all methods that are
*applicable*. That are those methods, for which the family predicate
returns `true' when applied to the families of the arguments and for which
all filters for all arguments return `true'. These methods then are sorted
according to an ``implicit value'': For each filter involved in one of the
<argflags> one point is given. That is, if we define `IsC' as `IsA and
IsB', then `IsC and IsD' gets 3 points (or even more if `IsA', `IsB' or
`IsD' are composite themselves).
To this number the installed <value> is
added.
(Actually this sorting can take place already when installing the method, so
there is no time loss for this during execution.)
Then the method with the highest value is executed and any result it returns
returned as the result of the operation.

This ``value business' allows for three aims: First, usually (nobody should
install such a method otherwise) a special method will be better than a
general one. This special method then however would have more filters in its 
<argflags>, thus get a higher implicit value and is favoured if applicable.

Second, there may be the case of concurrent methods whose specifications are
not subsets of each other. Suppose, for example we have two (simple) filters,
`IsBourbakian' and `IsLowerRegularQ' which have no relation whatsoever.
Suppose for an operation we have one method each installed for both filters.
If we now call this operation with an argument that is bourbakian and
fulfills the lower regular Q property, the method whose <value> is larger
gets selected. This allows to tell {\GAP} which filters will  lead to
especially cheap methods for certain operations.

Thirdly, giving a high value to a method permits to override decisions taken
before. If for example for test purposes a more general method should be
used, it is sufficient to install this method with a higher value than the
special one.

\danger
To speed up the process of method selection, each method caches the last 3
tuples of kinds with which it got called and the method selected for these.
This allows the selection process to proceed very swiftly in cases (like
multiplications) where the same method is called very frequently.

\danger
The list of (applicable) methods for an operation is always sorted in a way
to have newer methods coming first. Thus a method installed with the same
parameters as an existing method will supersede this. This allows to
re-install a corrected method (beware of problems here if the corrected
method calls `TryNextMethod'!).


Immediate methods can lead to substantial losses in runtime if a
method gets called too often or if the function installed actually *takes*
time. They should be used with care!

\danger
For calling immediate methods, {\GAP} actually does the following: 
Whenever a filter is set for an object, all installed immediate methods,
that need this filter to be applicable are run if the attribute is not yet
known and if they are applicable.

\danger
If you are creating objects and setting attributes in them you might want to
avoid immediate methods to be run, as you will set the immediately obtainable
attributes yourself. This can be acchieved using the variable

\){\fmark IGNORE_IMMEDIATE_METHODS}

While this variable is set to `true' (it is set to `false' by default) no
immediate methods will be called.


\danger
To save memory,
{\GAP} internally keeps a list of all known kinds. NewKind actually will
only create a new kind if it is not in this list and otherwise return a
kind from
this list, if it fulfills exactly the requirements. A cache for the most
recent kinds is used to avoid long searches over the list of all kinds.

Whenever new filters are set for an object, its kind changes, if necessary
creating a new kind implicitely.

The method selection mechanism actually only looks at the kinds of the
arguments and fetches the necessary informations from them.

\danger
As kind are objects themselves, they also have a kind and a family.
These are the `FamilyOfKinds' and the `KindOfKinds'.

\danger
Despite the caching of kinds, if you expect to create a lot of
new objects (as, for example, when implementing new arithmetical objects,
where each infix opertion will create a new object), it can be helpful to
store the *default kinds* (the kinds with which objects will be
created) in the family to avoid calls to `NewKind' (see "storeinfamily").


\Section{Family Predicates}

In this section we list some common family predicates used throughout the
library.

\beginitems
`IsElmsColls(<A>,<B>)'&

`IsNotElmsColls(<A>,<B>)'&

`IsElmsCollColls(<A>,<B>,<C>)'&

`IsCollsElms(<A>,<B>)'&

`IsCollCollsElms(<A>,<B>,<C>)'&

`IsCollsElmsElms(<A>,<B>,<C>)'&

`IsCollsElmsElmsElms(<A>,<B>,<C>,<D>)'&

`IsCollsElmsElmsX(<A>,<B>,<C>,<D>)'&

`IsCollCollsElmsElms(<A>,<B>,<C>,<D>)'&

`IsCollsCollsElms(<A>,<B>,<C>)'&

`IsCollsXElms(<A>,<B>,<C>)'&

`IsFamFamXY(<A>,<B>,<C>,<D>)'&

`IsLieFamFam(<A>,<B>,<C>)'&

`IsFamLieFam(<A>,<B>,<C>)'&

`IsElmsLieColls(<A>,<B>,<C>)'&

`IsElmsCollLieColls(<A>,<B>,<C>,<D>)'&

`IsCollLieCollsElms(<A>,<B>,<C>,<D>)'&

`IsCoeffsElms(<A>,<B>)'&

`IsElmsCoeffs(<A>,<B>)'&

`FamRangeEqFamElm(<A>,<B>)'&

`FamSourceEqFamElm(<A>,<B>)'&

`CollFamRangeEqFamElms(<A>,<B>)'&

`CollFamSourceEqFamElms(<A>,<B>)'&

`FamElmEqFamRange(<A>,<B>)'&

`FamElmEqFamSource(<A>,<B>)'&

`FamSource2EqFamRange1(<A>,<B>)'&

`FamSource1EqFamRange2(<A>,<B>)'&

`FamRange1EqFamRange2(<A>,<B>)'&

`FamMapFamSourceFamRange(<A>,<B>)'&

`FamSourceRgtEqFamsLft(<A>,<B>)'&

`FamSourceNotEqFamElm(<A>,<B>)'&

`FamRangeNotEqFamElm(<A>,<B>)'&

`IsMagmaRingsRings(<A>,<B>)'&

`IsRingsMagmaRings(<A>,<B>)'&

`IsMagmasMagmaRings(<A>,<B>)'&

\enditems

