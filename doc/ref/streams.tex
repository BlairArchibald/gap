%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  streams.tex               GAP documentation              Frank Celler
%W                                                     & Martin Schoenert
%%
%H  @(#)$Id$
%%
%Y  Copyright 1997,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,   Germany
%%
%%  This file contains the description of streams.
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\PreliminaryChapter{Streams}

Files can be read and  written using `Read'  and `AppendTo', however, the
former allows only to read a complete file as {\GAP} input and the latter
has a high time penalty if a lot of small pieces of output are written to
large files.

In addition  to  `Read'  and `AppendTo'  files  can  also be  accessed as
*streams*.  An *input stream* delivers characters to {\GAP} which *reads*
them from the stream.  When an  input stream has delivered all characters
it is  at `end-of-stream'.  An  *output  stream* receives characters from
{\GAP} which *writes* them   to  the stream.    Streams differ in   their
treatment of `end-of-line' and  non-printable characters.  *Text streams*
translate the `end-of-line'     character (`{'\\n'}')  to  the    systems
representation   of   `end-of-line'   (e.g.,    <new-line>  under   UNIX,
<carriage-return> under  MacOS,  <carriage-return>-<new-line> under  DOS,
implicit under VMS), and  the behaviour  for nonprintable characters   is
undefined.  *Binary streams* do not translate the `end-of-line' character
and allow nonprintable characters.

Note that binary streams are *@not yet implemented@*.

Whereas it is cheap  to append  to a stream,   streams do consume  system
resources, and only  a limited number can  be open at any time, therefore
it   is neccessary  to   close a   stream  as  soon   as possible   using
`CloseStream'  described in Section~"CloseStream".   If creating a stream
failed then `LastSystemError' (see "LastSystemError")  can be used to get
information about the  failure.  However, if an  error occurred in one of
the read or write functions `LastError' (see "LastError") should be used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{File Streams}

File streams  are  streams associated with  files.  An  input file stream
reads  the characters  it delivers from  a  file,  an output  file stream
prints the characters it receives to a file.  The following functions can
be used to create such streams.  They return `fail' if an error occurred,
in this case `LastSystemError' (see "LastSystemError") can be used to get
information about the error.

\>InputTextFile( <name-file> ) O

returns an input stream in the category `IsInputTextStream' that delivers
the characters from the file <name-file>.

\>OutputTextFile( <name-file>, <append> ) O

returns  an output stream  in the category `IsOutputTextFile' that writes
received characters  to the file   <name-file>.  If <append> is  `false',
then the  file is emptied first,  otherwise received characters are added
at the end of the list.

*Example*

\begintt
# use a temporary directory
gap> name := Filename( DirectoryTemporary(), "test" );;

# create an output stream, append output, and close again
gap> output := OutputTextFile( name, true );;
gap> AppendTo( output, "Hallo\n", "You\n" );
gap> CloseStream(output);

# create an input, print complete contents of file, and close
gap> input := InputTextFile(name);;
gap> Print( ReadAll(input) );
Hallo
You
gap> CloseStream(input);

# append a single line
gap> output := OutputTextFile( name, true );; 
gap> AppendTo( output, "AppendLine\n" );

# close output stream to flush the output
gap> CloseStream(output);


# create an input, print complete contents of file, and close
gap> input := InputTextFile(name);;
gap> Print( ReadAll(input) );
Hallo
You
AppendLine
gap> CloseStream(input);
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{String Streams}

String streams   are streams associated  with   strings.  An input string
stream reads  the characters it delivers  from a string, an output string
stream  appends the characters  it receives  to  a string.  The following
functions can be used to create such streams.

\>InputTextString( <string> ) O

returns an  input stream that  delivers the  characters  from the  string
<string>.  The  <string> is not changed when  reading characters  from it
and  changing  the <string> after  the  call to `InputTextString'  has no
influence on the input stream.

\>OutputTextString( <list>, <append> ) O

returns an output stream that puts  all received characters into the list
<list>.   If <append>   is  `false',  then  the list   is  emptied first,
otherwise received characters are added at the end of the list.

*Example*

\begintt
# read input from a string
gap> input := InputTextString( "Hallo\nYou\n" );;
gap> ReadLine(input);
"Hallo\n"
gap> ReadLine(input);
"You\n"

# print to a string
gap> str := "";;
gap> out := OutputTextString( str, true );;
gap> PrintTo( out, 1, "\n", (1,2,3,4)(5,6), "\n" );
gap> CloseStream(out);
gap> Print( str );
1
(1,2,3,4)(5,6)
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Dummy Streams}

The following  two commands create  dummy streams  which will consume all
characters and never deliver one.


\>InputTextNone() F

returns a dummy input text stream, which delivers no characters, i.e., it
is always at end of stream.  Its main use  is for calls to `Process' (see
"Process") when the started program does not read anything.

\>OutputTextNone() F

returns a dummy output   stream, which discards all received  characters.
Its main use is for calls to `Process' when  the started program does not
write anything.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{CloseStream}

\>CloseStream( <stream> ) O

In order  to preserve system resources  and to flush output streams every
stream should  be  closed  as soon   as  it is   no longer   used using
`CloseStream'.

It is an error to  try to read  characters from or  write characters to a
closed  stream.   Closing a  stream tells  the {\GAP}   kernel and/or the
operating system kernel  that the file is  no longer needed.  This may be
necessary  because  the {\GAP} kernel  and/or  the  operating  system may
impose a limit on how many streams may be open simultaneously.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Input Stream Operations}

\>IsEndOfStream( <input-stream> ) O

returns `true' if  the input stream  is  at `end-of-stream', and  `false'
otherwise.  Note  that `IsEndOfStream' might return  `false' even  if the
next `ReadByte' fails.

\>Read( <input-text-stream> )!{for streams} O

reads the input-text-stream as  input  until `end-of-stream' occurs.  See
"File Operations" for details.

\>ReadAsFunction( <input-text-stream> )!{for streams} O

reads the input-text-stream as function and returns this function.

\>ReadTest( <input-text-stream> )!{for streams} O

reads the input-text-stream as  test input until `end-of-stream' occurs.
See "File Operations" for details.

*Example*

\beginexample
# as function with local `a' does not change the global one
gap> a := 1;;
gap> i := InputTextString( "local a; a := 10; return a*10;" );;
gap> ReadAsFunction(i)();
100
gap> a;
1

# reading it via `Read' does
gap> i := InputTextString( "a := 10;" );;                      
gap> Read(i);
gap> a;
10
\endexample

\>ReadByte( <input-text-stream> ) O

returns the  next character as  integer  or `fail'  if <input-stream> has
reached the `end-of-stream'.

\>ReadLine( <input-text-stream> ) O

returns  the   next line as   string  *including*  the  newline character
`{'\\n'}' or `fail' if <input-stream> has reached `end-of-stream'.

Note that *no* newline is added if the last line is incomplete.

\>ReadAll( <input-text-stream> ) O

returns   the  whole available input as    string.  If <input-stream> has
reached `end-of-stream' an empty string is returned, *not* `fail'.

*Example*

\beginexample
gap> i := InputTextString( "1Hallo\nYou\n1" );;
gap> ReadByte(i);
49
gap> CHAR_INT(last);
'1'
gap> ReadLine(i);
"Hallo\n"
gap> ReadLine(i);
"You\n"
gap> ReadLine(i);
"1"
gap> ReadLine(i);
fail
gap> ReadAll(i);
[]
gap> RewindStream(i);;
gap> ReadAll(i);     
"1Hallo\nYou\n1"
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Output Stream Operations}

\>WriteByte( <output-stream>, <int> ) O

writes the  next  character  (given  as *integer*)  to the  output stream
<output-stream>.  The function  returns `true' if  the write succeeds and
`fail' otherwise.

\>WriteAll( <output-stream>, <string> ) O

appends  <string> to <output-stream>.   No final  newline is written.
The function returns `true' if the write succeeds and `fail' otherwise.

\>WriteLine( <output-stream>, <string> ) O

appends  <string> to <output-stream>.   A  final newline is written.
The function returns `true' if the write succeeds and `fail' otherwise.

*Example*

\beginexample
gap> str := "";; a := OutputTextString(str,true);;
gap> WriteByte(a,INT_CHAR('H'));
true
gap> WriteLine(a,"allo");
true
gap> WriteAll(a,"You\n");
true
gap> CloseStream(a);
gap> Print(str);
Hallo
You
\endexample

\>AppendTo( <output-stream>, <arg1>, ... )!{for streams} F

works like  `Print',  except that the  output is  appended to the  output
stream <output-stream>.

*Example*

\beginexample
gap> str := "";; a := OutputTextString(str,true);;
gap> AppendTo( a, (1,2,3), ":", Z(3) );
gap> CloseStream(a);
gap> Print( str, "\n" );
(1,2,3):Z(3)
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E  streams.tex . . . . . . . . . . . . . . . . . . . . . . . . ends here
