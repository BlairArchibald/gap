%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  lists.msk                   GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Lists}

Lists are the most important way to treat objects together.
A *list* arranges objects in a definite order.
So each list implies a partial mapping from the integers to the elements
of the list.
I.e., there is a first element of a list, a second, a third, and so on.
Lists can occur in mutable or immutable form,
see~"Mutability and Copyability" for the concept of mutability,
and~"Duplication of Lists" for the case of lists.

This chapter deals mainly with the aspect of lists in {\GAP}
as *data structures*.
Chapter~"Collections" tells more about the *collection* aspect of certain
lists,
and more about lists as *arithmetic objects* can be found in the chapters
"Row Vectors" and "Matrices".

Lists are used to implement ranges (see~"Ranges"),
sets (see~"Sorted Lists and Sets"),\index{Sets}
strings (see~"Strings and Characters"),
row vectors (see~"Row Vectors"), and matrices (see~"Matrices");
Boolean lists (see~"Boolean Lists") are a further special kind of lists.

Several operations for lists, such as `Intersection' and `Random',
will be described in Chapter~"Collections",
in particular see~"Lists and Collections".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{List Categories}

A list can be written by writing down the elements in order between
square brackets `[', `]', and separating them with commas `,'. An *empty
list*, i.e., a list with no elements, is written as `[]'.

\beginexample
gap> [ 1, 2, 3 ];
[ 1, 2, 3 ]  # a list with three elements
gap> [ [], [ 1 ], [ 1, 2 ] ];
[ [  ], [ 1 ], [ 1, 2 ] ]  # a list may contain other lists
\endexample

Each list constructed this way is mutable (see~"Mutability and Copyability").

\Declaration{IsList}
\beginexample
gap> IsList( [ 1, 3, 5, 7 ] );  IsList( 1 );
true
false
\endexample

\Declaration{IsDenseList}
\begintt
gap> IsDenseList( [ 1, 2, 3 ] );
true
gap> l := [ , 4, 9,, 25,, 49,,,, 121 ];;  IsDenseList( l );
false
gap> l[3];
9
gap> l[4];
List Element: <list>[4] must have an assigned value
not in any function
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' after assigning a value to continue
brk> l[4] := 16;; # assigning a value
brk> return;      # to escape the break-loop
16
gap> 
\endtt

Observe that requesting the value of `l[4]', which was not
assigned, caused the entry of a `break'-loop (see Section~"Break Loops").
After assigning a value and typing `return;', {\GAP} is finally
able to comply with our request (by responding with `16').

\Declaration{IsHomogeneousList}
\beginexample
gap> IsHomogeneousList( [ 1, 2, 3 ] );  IsHomogeneousList( [] );
true
true
gap> IsHomogeneousList( [ 1, false, () ] );
false
\endexample

\Declaration{IsTable}
\beginexample
gap> IsTable( [ [ 1, 2 ], [ 3, 4 ] ] );        # in fact a matrix
true
gap> IsTable( [ [ 1 ], [ 2, 3 ] ] );           # not rectangular but a table
true
gap> IsTable( [ [ 1, 2 ], [ () , (1,2) ] ] );  # not homogeneous
false
\endexample

\Declaration{IsConstantTimeAccessList}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Basic Operations for Lists}

The basic operations for lists are element access (see~"List Elements"),
assignment of elements to a list (see~"List Assignment"),
fetching the length of a list (see~"Length"),
the test for a hole at a given position, and unbinding an element at a given
position (see~"IsBound and Unbind for Lists").

The term basic operation means that each other list operation can be
formulated in terms of the basic operations.
(But note that usually a more efficient method than this one is implemented.)

Any {\GAP} object <list> in the category `IsList' (see~"IsList") is regarded
as a list, and if methods for the basic list operations are installed for
<list> then <list> can be used also for the other list operations.

For internally represented lists, kernel methods are provided for the basic
list operations.
For other lists, it is possible to install appropriate methods for these
operations.
This permits the implementation of lists that do not need to store all list
elements (see also~"Enumerators");
for example, the elements might be described by an algorithm, such as the
elements list of a group.
For this reduction of space requirements, however, a price in access time
may have to be paid (see~"ConstantTimeAccessList").

\>`\\[\\]( <list>, <pos> )'{list element!operation} O
\>`IsBound\\[\\]( <list>, <pos> )'{list boundedness test!operation} O
\>`\\[\\]\\:\\=( <list>, <pos>, <val> )'{list assignment!operation} O
\>`Unbind\\[\\]( <list>, <pos> )'{list unbind!operation} O

These operations implement element access, test for element boundedness,
list element assignment, and removal of the element at position <pos>.
In all cases, the index <pos> must be a positive integer.

Note that the special characters `[', `]', `:', and `=' must be escaped with
a backslash `\\' (see~"Symbols");
so `\\[\\]' denotes the operation for element access in a list,
whereas `[]' denotes an empty list.
(Maybe the variable names involving special characters look strange,
but nevertheless they are quite suggestive.)

`\\[\\]( <list>, <pos> )' is equivalent to `<list>[ <pos> ]',
which clearly will usually be preferred;
the former is useful mainly if one wants to access the operation itself,
for example if one wants to install a method for element access in a
special kind of lists.

Similarly, `IsBound\\[\\]' is used explicitly mainly in method installations.
In other situations, one can simply call `IsBound', which then delegates to
`IsBound\\[\\]' if the first argument is a list, and to `IsBound\\.' if the
first argument is a record.

Analogous statements hold for `\\[\\]\\:\\=' and `Unbind\\[\\]'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{List Elements}

\index{accessing!list elements}
\>`<list>[ <pos> ]'{list element!access}

The above construct evaluates to the <pos>-th element of the list <list>.
<pos> must be a positive integer. List indexing is done with origin 1,
i.e., the first element of the list is the element at position 1.
\beginexample
gap> l := [ 2, 3, 5, 7, 11, 13 ];;  l[1];  l[2];  l[6];
2
3
13
\endexample
If <list> is not a list, or <pos> does not evaluate to a
positive integer, or `<list>[<pos>]' is unbound an error is signalled.

\>`<list>\{ <poss> \}'{sublist!access}

\index{sublist}
The above construct evaluates to a new list <new> whose first element is
`<list>[<poss>[1]]', whose second element is `<list>[<poss>[2]]', and so
on. <poss> must be a dense list of positive integers. However, it does not
need to be sorted and may contain duplicate elements. If for any <i>,
`<list>[ <poss>[<i>] ]' is unbound, an error is signalled.

\beginexample
gap> l := [ 2, 3, 5, 7, 11, 13, 17, 19 ];;
gap> l{[4..6]};  l{[1,7,1,8]};
[ 7, 11, 13 ]
[ 2, 17, 2, 19 ]
\endexample

The result is a *new* list, that is not identical to any other list. The
elements of that list, however, are identical to the corresponding elements
of the left operand (see~"Identical Lists").

It is possible to nest such *sublist extractions*, as can be seen in the
following example.

\beginexample
gap> m := [ [1,2,3], [4,5,6], [7,8,9], [10,11,12] ];;  m{[1,2,3]}{[3,2]};
[ [ 3, 2 ], [ 6, 5 ], [ 9, 8 ] ]
gap> l := m{[1,2,3]};; l{[3,2]};
[ [ 7, 8, 9 ], [ 4, 5, 6 ] ]
\endexample

Note the difference between the two examples.  The latter extracts
elements 1, 2, and 3 from <m> and then extracts the elements 3 and 2 from
*this list*. The former extracts elements 1, 2, and 3 from <m> and then
extracts the elements 3 and 2 from *each of those element lists*.

To be precise: With each selector `[<pos>]' or `\{<poss>\}' we associate
a *level* that is defined as the number of selectors of the form
`\{<poss>\}' to its left in the same expression. For example

\begintt
    l[pos1]{poss2}{poss3}[pos4]{poss5}[pos6]
level   0      0      1     1      1     2
\endtt

Then  a selector `<list>[<pos>]' of level <level> is computed as
`ListElement(<list>,<pos>,<level>)', where `ListElement' is defined as
follows.
(Note that `ListElement' is *not* a {\GAP} function.)

\begintt
ListElement := function ( list, pos, level )
 if level = 0 then
  return list[pos];
 else
  return List( list, elm -> ListElement(elm,pos,level-1) );
 fi;
end;
\endtt

and a selector `<list>\{<poss>\}' of level <level> is computed as
`ListElements(<list>,<poss>,<level>)', where `ListElements' is defined as
follows.
(Note that `ListElements' is *not* a {\GAP} function.)

\begintt
ListElements := function ( list, poss, level )
 if level = 0 then
  return list{poss};
  else
   return List( list, elm -> ListElements(elm,poss,level-1) );
  fi;
end;
\endtt


\>`\\\{\\\}( <list>, <poss> )'{sublist!operation} O

This operation implements *sublist access*.
For any list, the default method is to loop over the entries in the list
<poss>, and to delegate to the element access operation.
(For the somewhat strange variable name, cf.~"Basic Operations for Lists".)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{List Assignment}

\index{assignment!to a list}
\>`<list>[ <pos> ] := <object>;'{list element!assignment}

The list element assignment assigns the object <object>,
which can be of any type, to the list entry at the position <pos>,
which must be a positive integer,
in the mutable (see~"Mutability and Copyability") list <list>.
That means that accessing the <pos>-th element of the list <list> will
return <object> after this assignment.

\beginexample
gap> l := [ 1, 2, 3 ];;
gap> l[1] := 3;; l;             # assign a new object
[ 3, 2, 3 ]
gap> l[2] := [ 4, 5, 6 ];; l;   # <object> may be of any type
[ 3, [ 4, 5, 6 ], 3 ]
gap> l[ l[1] ] := 10;; l;       # <index> may be an expression
[ 3, [ 4, 5, 6 ], 10 ]
\endexample

If the index <pos> is larger than the length of the list <list> (see
"Length"), the list is automatically enlarged to make room for the new
element. Note that it is possible to generate lists with holes that way.

\beginexample
gap> l[4] := "another entry";; l; # <list> is enlarged
[ 3, [ 4, 5, 6 ], 10, "another entry" ]
gap> l[ 10 ] := 1;; l;            # now <list> has a hole
[ 3, [ 4, 5, 6 ], 10, "another entry",,,,,, 1 ]
\endexample

The  function `Add' (see "Add") should be used if you want to add an
element to the end of the list.

Note that assigning to a list changes the list,
thus this list must be mutable (see~"Mutability and Copyability").
See~"Identical Lists" for subtleties of changing lists.

If <list> does not evaluate to a list, <pos> does not evaluate to a
positive integer or <object> is a call to a function which does not
return a value (for example `Print') an error is signalled.

\>`<list>\{ <poss> \} := <objects>;'{sublist!assignment}

The sublist assignment assigns the object `<objects>[1]', which can be of
any type, to the list <list> at the position `<poss>[1]', the object
`<objects>[2]' to `<list>[<poss>[2]]', and so on. <poss> must be a dense
list of positive integers, it need, however, not be sorted and may
contain duplicate elements. <objects> must be a dense list and must have
the same length as <poss>.

\beginexample
gap> l := [ 2, 3, 5, 7, 11, 13, 17, 19 ];;
gap> l{[1..4]} := [10..13];; l;
[ 10, 11, 12, 13, 11, 13, 17, 19 ]
gap> l{[1,7,1,10]} := [ 1, 2, 3, 4 ];; l;
[ 3, 11, 12, 13, 11, 13, 2, 19,, 4 ]
\endexample

It is possible to nest such sublist assignments, as can be seen in the
following example.

\beginexample
gap> m := [ [1,2,3], [4,5,6], [7,8,9], [10,11,12] ];;
gap> m{[1,2,3]}{[3,2]} := [ [11,12], [13,14], [15,16] ];; m;
[ [ 1, 12, 11 ], [ 4, 14, 13 ], [ 7, 16, 15 ], [ 10, 11, 12 ] ]
\endexample

The exact behaviour is defined in the same way as for list extractions
(see  "List Elements").  Namely  with each  selector `[<pos>]' or
`\{<poss>\}' we associate a *level* that is defined as the number of
selectors of the form `\{<poss>\}' to its left in the same expression.
For example

\begintt
    l[pos1]{poss2}{poss3}[pos4]{poss5}[pos6]
level   0      0      1     1      1     2
\endtt

Then a list assignment `<list>[<pos>] := <vals>;' of level <level> is
computed as `ListAssignment( <list>, <pos>, <vals>, <level> )', where
`ListAssignment' is defined as follows.
(Note that `ListAssignment' is *not* a {\GAP} function.)

\begintt
ListAssignment := function ( list, pos, vals, level )
 local i;
 if level = 0 then
  list[pos] := vals;
 else
  for i in [1..Length(list)] do
   ListAssignment( list[i], pos, vals[i], level-1 );
  od;
 fi;
end;
\endtt

and a list assignment `<list>\{<poss>\} := <vals>' of level <level> is
computed as `ListAssignments( <list>, <poss>, <vals>, <level> )', where
`ListAssignments' is defined as follows.
(Note that `ListAssignments' is *not* a {\GAP} function.)

\begintt
ListAssignments := function ( list, poss, vals, level )
 local i;
 if level = 0 then
  list{poss} := vals;
 else
  for i in [1..Length(list)] do
   ListAssignments( list[i], poss, vals[i], level-1 );
  od;
 fi;
end;
\endtt

\>`\\\{\\\}\\:\\=( <list>, <poss>, <val> )'{sublist assignment!operation} O

This operation implements sublist assignment.
For any list, the default method is to loop over the entries in the list
<poss>, and to delegate to the element assignment operation.
(For the somewhat strange variable name, cf.~"Basic Operations for Lists".)


\Declaration{Add}
\beginexample
gap> l := [ 2, 3, 5 ];; Add( l, 7 ); l;
[ 2, 3, 5, 7 ]
\endexample

\Declaration{Append}
\beginexample
gap> l := [ 2, 3, 5 ];; Append( l, [ 7, 11, 13 ] ); l;
[ 2, 3, 5, 7, 11, 13 ]
gap> Append( l, [ 17,, 23 ] ); l;
[ 2, 3, 5, 7, 11, 13, 17,, 23 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{IsBound and Unbind for Lists}

\>IsBound( <list>[<n>] )!{for lists} M

`IsBound' returns `true' if the list <list> has a
element at the position <n>, and `false' otherwise.
<list> must evaluate to a list, otherwise an error is signalled.

\beginexample
gap> l := [ , 2, 3, , 5, , 7, , , , 11 ];;
gap> IsBound( l[7] );
true
gap> IsBound( l[4] );
false
gap> IsBound( l[101] );
false
\endexample

\>Unbind( <list>[<n>] )!{for lists} M

`Unbind' deletes the element at the position <n> in the mutable list <list>.
That is, after execution of `Unbind', <list> no longer
has an assigned value at the position <n>.
Thus `Unbind' can be used to produce holes in a list.
Note that it is not an error to unbind a nonexisting list element.
<list> must evaluate to a list, otherwise an error is signalled.

\beginexample
gap> l := [ , 2, 3, 5, , 7, , , , 11 ];;
gap> Unbind( l[3] ); l;
[ , 2,, 5,, 7,,,, 11 ]
gap> Unbind( l[4] ); l;
[ , 2,,,, 7,,,, 11 ]
\endexample

Note that `IsBound' and `Unbind' are special in that they do not evaluate
their argument, otherwise `IsBound' would always signal an error when it is
supposed to return `false' and there would be no way to tell `Unbind' which
component to remove.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Lists}

With the list assignment (see~"List Assignment") it is
possible  to change a mutable list.
This section describes the semantic consequences of this fact.
(See also~"Identical Objects".)

First we define what it means when we say that ``an object is changed''.
You may think that in the following example the second assignment changes
the integer.

\begintt
i := 3;
i := i + 1;
\endtt

But in this example it is not the *integer* `3' which is changed,
by adding one to it.
Instead the *variable* `i' is changed by assigning the value of `i+1',
which happens to be `4', to `i'. The same thing happens in the following
example

\begintt
l := [ 1, 2 ]
l := [ 1, 2, 3 ];
\endtt

The second assignment does not change the first list, instead it assigns
a new list to the variable `l'.  On the other hand, in the following
example the list *is* changed by the second assignment.

\begintt
l := [ 1, 2 ];
l[3] := 3;
\endtt

To understand the difference, think of a variable as a name for an
object. The important point is that a list can have several names at the
same time.  An  assignment `<var>:=<list>;' means in  this
interpretation that <var> is a name for the object <list>. At the end of
the following example `l2' still has the value `[ 1, 2 ]' as this list
has not been changed and nothing else has been assigned to it.

\begintt
l1 := [ 1, 2 ];
l2 := l1;
l1 := [ 1, 2, 3 ];
\endtt

But after the following example the list for which `l2' is a name has
been changed and thus the value of `l2' is now `[ 1, 2, 3 ]'.

\begintt
l1 := [ 1, 2 ];
l2 := l1;
l1[3] := 3;
\endtt

We say that two lists are *identical* if changing one of them by a
list assignment also changes the other one.  This is slightly incorrect,
because if *two* lists are identical, there are actually only two names
for *one* list. However, the correct usage would be very awkward and
would only add to the confusion.  Note that two identical lists must be
equal, because there is only one list with two different names. Thus
identity is an equivalence relation that is a refinement of equality.
Identity of objects can be detected using `IsIdenticalObj',
see~"Identical Objects".

Let us now consider under which circumstances two lists are identical.

If you enter a list literal then the list denoted by this literal is a
new list that is not identical to any other list. Thus in the following
example `l1' and `l2' are not identical, though they are equal of course.

\begintt
l1 := [ 1, 2 ];
l2 := [ 1, 2 ];
\endtt

Also in the following example, no lists in the list `l' are identical.

\begintt
l := [];
for i in [1..10] do l[i] := [ 1, 2 ]; od;
\endtt

If you assign a list to a variable no new list is created. Thus the list
value of the variable on the left hand side and the list on the right
hand side of the assignment are identical. So in the following example
`l1' and `l2' are identical lists.

\begintt
l1 := [ 1, 2 ];
l2 := l1;
\endtt

If you pass a list as an argument, the old list and the argument of the
function are identical. Also if you return a list from a function, the
old list and the value of the function call are identical. So in the
following example `l1' and `l2' are identical lists:

\begintt
l1 := [ 1, 2 ];
f := function ( l ) return l; end;
l2 := f( l1 );
\endtt

If you change a list it keeps its identity.  Thus if two lists are
identical and you change one of them, you also change the other, and they
are still identical afterwards. On the other hand, two lists that are
not identical will never become identical if you change one of them. So
in the following example both `l1' and `l2' are changed, and are still
identical.

\begintt
l1 := [ 1, 2 ];
l2 := l1;
l1[1] := 2;
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Duplication of Lists}

Here we describe the meaning of `ShallowCopy' and `StructuralCopy' for
lists.
For the general definition of these functions,
see~"Duplication of Objects".

\indextt{ShallowCopy!for lists}
The subobjects (see~"ShallowCopy") of a list are exactly its elements.

This means that for any list <list>, `ShallowCopy' returns a mutable
*new* list <new> that is *not identical* to any other list
(see~"Identical Lists"),
and whose elements are identical to the elements of <list>.

\indextt{StructuralCopy!for lists}
Analogously, for a *mutable* list <list>, `StructuralCopy' returns a
mutable *new* list <scp> that is *not identical* to any other list,
and whose elements are structural copies (defined recursively)
of the elements of <list>;
an element of <scp> is mutable (and then a *new* list) if and only if
the corresponding element of <list> is mutable.

In both cases, modifying the copy <new> resp.~<scp> by assignments
(see~"List Assignment") does not modify the original object <list>.

`ShallowCopy' basically executes the following code for lists.
\begintt
new := [];
for i in [ 1 .. Length( list ) ] do
  if IsBound( list[i] ) then
    new[i] := list[i];
  fi;
od;
\endtt

\beginexample
gap> list1 := [ [ 1, 2 ], [ 3, 4 ] ];;  list2 := ShallowCopy( list1 );;
gap> IsIdenticalObj( list1, list2 );
false
gap> IsIdenticalObj( list1[1], list2[1] );
true
gap> list2[1] := 0;;  list1;  list2;
[ [ 1, 2 ], [ 3, 4 ] ]
[ 0, [ 3, 4 ] ]
\endexample

`StructuralCopy' basically executes the following code for lists.
\begintt
new := [];
for i in [ 1 .. Length( list ) ] do
  if IsBound( list[i] ) then
    new[i] := StructuralCopy( list[i] );
  fi;
od;
\endtt

\beginexample
gap> list1 := [ [ 1, 2 ], [ 3, 4 ] ];;  list2 := StructuralCopy( list1 );;
gap> IsIdenticalObj( list1, list2 );
false
gap> IsIdenticalObj( list1[1], list2[1] );
false
gap> list2[1][1] := 0;;  list1;  list2;
[ [ 1, 2 ], [ 3, 4 ] ]
[ [ 0, 2 ], [ 3, 4 ] ]
\endexample

The above code is not entirely correct. If the object <list> contains a
mutable object twice this object is not copied twice,
as would happen with the above definition, but only once.
This means that the copy <new> and the object <list> have exactly the
same structure when viewed as a general graph.

\beginexample
gap> sub := [ 1, 2 ];; list1 := [ sub, sub ];;
gap> list2 := StructuralCopy( list1 );
[ [ 1, 2 ], [ 1, 2 ] ]
gap> list2[1][1] := 0;; list2;
[ [ 0, 2 ], [ 0, 2 ] ]
gap> list1;
[ [ 1, 2 ], [ 1, 2 ] ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Membership Test for Lists}

\indextt{in!for lists}
\>`<obj> in <list>'{element test}!{for lists}

tests whether there is a positive integer <index> such that
`<list>[ <index> ] = <obj>'.

If the list <list> knows that it is strictly sorted (see~"IsSSortedList"),
the membership test is much quicker, because a binary search can be used
instead of the linear search used for arbitrary lists.

\beginexample
gap> 1 in [ 2, 2, 1, 3 ];  1 in [ 4, -1, 0, 3 ];
true
false
gap> s := SSortedList( [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32] );;
gap> 17 in s;
false        # uses binary search and only 4 comparisons
\endexample

For finding the position of an element in a list,
see~"Finding Positions in Lists".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Enlarging Internally Represented Lists}

Section~"List Assignment" told you (among other things) that it is
possible to assign beyond the logical end of a mutable list,
automatically enlarging the list.
This section tells you how this is done for internally represented lists.

It would be extremely wasteful to make all lists large enough so that
there is room for all assignments, because some lists may have more than
100000 elements, while most lists have less than 10 elements.

On the other hand suppose every assignment beyond the end of a list would
be done by allocating new space for the list and copying all entries to
the new space. Then creating a list of 1000 elements by assigning them
in order, would take half a million copy operations and also create a lot
of garbage that the garbage collector would have to reclaim.

So the following strategy is used.  If a list is created it is created
with exactly the correct size. If a  list is enlarged, because of an
assignment beyond  the end of the list,  it is enlarged  by at least
`<length>/8 + 4' entries. Therefore the next assignments beyond the end
of the list do not need to enlarge the list. For example creating a list
of 1000 elements by  assigning them in order,  would now take only 32
enlargements.

The result of this is of course that the *physical length* of a list
may be larger than the *logical length*,
which is usually called simply the length of the list.
Aside from the implications for the performance you need not be aware
of the physical length.
In fact all you can  ever observe, for  example by calling
`Length' (see~"Length"), is the logical length.

Suppose that `Length' would have to take  the physical length and then
test how many entries at the end of a list are unassigned, to compute the
logical length of the list. That would take too much time. In order to
make `Length', and other functions that need to know the logical length,
more efficient, the length of a list is stored along with the list.

%A note aside. In the previous version 2.4 of {\GAP} a list was indeed
%enlarged  every time an assignment beyond  the end of the list was
%performed. To deal with the above inefficiency the following hacks where
%used. Instead of creating lists in order they were usually created in
%reverse  order.  In situations  where this was not possible a dummy
%assignment to the last position was performed, for example
%
%  l := [];
%  l[1000] := "dummy";
%  l[1] := first_value();
%  for i from 2 to 1000 do l[i] := next_value(l[i-1]); od;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparisons of Lists}

\index{comparisons!of lists}
\>`<list1> = <list2>'{list equal!comparison}
\){\fmark <list1> \<> <list2>}

Two lists <list1> and <list2> are equal if and only if for
every index <i>, either both entries `<list1>[<i>]' and `<list2>[<i>]'
are unbound, or  both are bound and are equal, i.e., `<list1>[<i>] =
<list2>[<i>]' is `true'.

\beginexample
gap> [ 1, 2, 3 ] = [ 1, 2, 3 ];
true
gap> [ , 2, 3 ] = [ 1, 2, ];
false
gap> [ 1, 2, 3 ] = [ 3, 2, 1 ];
false
\endexample

This definition will cause problems with lists which are their own entries.
Comparing two such lists for equality may lead to an infinite recursion in
the kernel if the list comparison has to compare the list entries which are
in fact the lists themselves,
and then {\GAP} crashes.

\>`<list1> \<\ <list2>'{list smaller!comparison}
\){\fmark <list1> \<= <list2>}

Lists are ordered *lexicographically*.
Unbound entries are smaller than any bound entry.
That implies the following behaviour.
Let <i> be the smallest positive integer <i> such that <list1> and <list2>
at position <i> differ,
i.e., either exactly one of `<list1>[i]', `<list2>[i]' is bound or both
entries are bound and differ.
Then <list1> is less than <list2> if either `<list1>[<i>]' is unbound
(and `<list2>[<i>]' is not)
or both are bound and `<list1>[<i>] \< <list2>[<i>]' is `true'.

\beginexample
gap> [ 1, 2, 3, 4 ] < [ 1, 2, 4, 8 ];
true  # <list1>[3] < <list2>[3]
gap> [ 1, 2, 3 ] < [ 1, 2, 3, 4 ];
true  # <list1>[4] is unbound and therefore very small
gap> [ 1, , 3, 4 ] < [ 1, 2, 3 ];
true  # <list1>[2] is unbound and therefore very small
\endexample

Note that for comparing two lists with `\<' or `\<=',
the (relevant) list elements must be comparable with `\<',
which is usually *not* the case for objects in different families,
see~"Families".
Also for the possibility to compare lists with other objects,
see~"Families".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Arithmetic for Lists}

\index{operators!for lists}

It is convenient to have arithmetic operations for lists,
in particular because in {\GAP}
row vectors and matrices are special kinds of lists.
However, it is the wide variety of list objects because of which we
prescribe arithmetic operations *not for all* of them.
(Keep in mind that ``list'' means just an object in the category `IsList',
see~"IsList".)

(Due to the intended generality and flexibility,
the definitions given in the following sections are quite technical.
But for not too complicated cases
such as matrices (see~"Operators for Matrices")
and row vectors (see~"Operators for Row Vectors") whose entries aren't lists,
the resulting behaviour should be intuitive.)

For example, we want to deal with matrices which can be added and
multiplied in the usual way, via the infix operators `+' and `*';
and we want also Lie matrices, with the same additive behaviour but with
the multiplication defined by the Lie bracket.
Both kinds of matrices shall be lists, with the usual access to their rows,
with `Length' (see~"Length") returning the number of rows etc.

For the categories and attributes that control the arithmetic behaviour
of lists, see~"Filters Controlling the Arithmetic Behaviour of Lists".

For the definition of return values of additive and multiplicative operations
whose arguments are lists in these filters,
see~"Additive Arithmetic for Lists" and
"Multiplicative Arithmetic for Lists", respectively.
It should be emphasized that these sections describe only what the return
values are, and not how they are computed.

For the mutability status of the return values,
see~"Mutability Status and List Arithmetic".
(Note that this is not dealt with in the sections about the result values.)

Further details about the special cases of row vectors and matrices
can be found in~"Operators for Row Vectors" and in~"Operators for Matrices",
the compression status is dealt with in~"Row Vectors over Finite Fields"
and~"Matrices over Finite Fields".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Filters Controlling the Arithmetic Behaviour of Lists}

\FileHeader[1]{arith}

\Declaration{IsGeneralizedRowVector}
\Declaration{IsMultiplicativeGeneralizedRowVector}

Note that these filters do *not* enable default methods for addition or
multiplication (cf.~"IsListDefault").

\beginexample
gap> IsList( "abc" ); IsGeneralizedRowVector( "abc" );
true
false
gap> liemat:= LieObject( [ [ 1, 2 ], [ 3, 4 ] ] );
LieObject( [ [ 1, 2 ], [ 3, 4 ] ] )
gap> IsGeneralizedRowVector( liemat );
true
gap> IsMultiplicativeGeneralizedRowVector( liemat );
false
gap> bas:= CanonicalBasis( FullRowSpace( Rationals, 3 ) );
CanonicalBasis( ( Rationals^3 ) )
gap> IsMultiplicativeGeneralizedRowVector( bas );
true
\endexample


\Declaration{IsListDefault}

\beginexample
gap> v:= [ 1, 2 ];;  m:= [ v, 2*v ];;
gap> IsListDefault( v );  IsListDefault( m );
true
true
gap> IsListDefault( bas );  IsListDefault( liemat );
true
false
\endexample


\Declaration{NestingDepthA}
\Declaration{NestingDepthM}

\beginexample
gap> NestingDepthA( v );  NestingDepthM( v );
1
1
gap> NestingDepthA( m );  NestingDepthM( m );
2
2
gap> NestingDepthA( liemat );  NestingDepthM( liemat );
2
0
gap> l1:= [ [ 1, 2 ], 3 ];;  l2:= [ 1, [ 2, 3 ] ];;
gap> NestingDepthA( l1 );  NestingDepthM( l1 );
2
2
gap> NestingDepthA( l2 );  NestingDepthM( l2 );
1
1
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Additive Arithmetic for Lists}

In this general context, we define the results of additive operations
only in the following situations.
For unary operations (zero and additive inverse),
the unique argument must be in `IsGeneralizedRowVector';
for binary operations (addition and subtraction),
at least one argument must be in `IsGeneralizedRowVector',
and the other either is not a list or also in `IsGeneralizedRowVector'.

(For non-list {\GAP} objects, defining the results of unary operations is not
an issue here,
and if at least one argument is a list not in `IsGeneralizedRowVector',
it shall be left to this argument whether the result in question is defined
and what it is.)


*Zero*

The zero (see~"Zero") of a list $x$ in `IsGeneralizedRowVector'
is defined as the list whose entry at position $i$ is the zero of $x[i]$
if this entry is bound, and is unbound otherwise.

\beginexample
gap> Zero( [ 1, 2, 3 ] );  Zero( [ [ 1, 2 ], 3 ] );  Zero( liemat );
[ 0, 0, 0 ]
[ [ 0, 0 ], 0 ]
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
\endexample


*AdditiveInverse*

The additive inverse (see~"AdditiveInverse") of a list $x$ in
`IsGeneralizedRowVector' is defined as the list whose entry at position $i$
is the additive inverse of $x[i]$ if this entry is bound,
and is unbound otherwise.

\beginexample
gap> AdditiveInverse( [ 1, 2, 3 ] );  AdditiveInverse( [ [ 1, 2 ], 3 ] );
[ -1, -2, -3 ]
[ [ -1, -2 ], -3 ]
\endexample


*Addition*

\index{addition!list and non-list}

If $x$ and $y$ are in `IsGeneralizedRowVector' and have the same
additive nesting depth (see~"NestingDepthA"),
% By definition, this depth is nonzero.
the sum $x + y$ is defined *pointwise*, in the sense that the result is a
list whose entry at position $i$ is $x[i] + y[i]$ if these entries are bound,
is a shallow copy (see~"ShallowCopy") of $x[i]$ or $y[i]$ if the other
argument is not bound at position $i$,
and is unbound if both $x$ and $y$ are unbound at position $i$.

If $x$ is in `IsGeneralizedRowVector' and $y$ is
in `IsGeneralizedRowVector' and has lower additive nesting depth,
or is neither a list nor a domain,
the sum $x + y$ is defined as a list whose entry at position $i$ is
$x[i] + y$ if $x$ is bound at position $i$, and is unbound if not.
The equivalent holds in the reversed case,
where the order of the summands is kept,
as addition is not always commutative.

\beginexample
gap> 1 + [ 1, 2, 3 ];  [ 1, 2, 3 ] + [ 0, 2, 4 ];  [ 1, 2 ] + [ Z(2) ];
[ 2, 3, 4 ]
[ 1, 4, 7 ]
[ 0*Z(2), 2 ]
gap> l1:= [ 1, , 3, 4 ];;             l2:= [ , 2, 3, 4, 5 ];;
gap> l3:= [ [ 1, 2 ], , [ 5, 6 ] ];;  l4:= [ , [ 3, 4 ], [ 5, 6 ] ];;
gap> NestingDepthA( l1 );  NestingDepthA( l2 );
1
1
gap> NestingDepthA( l3 );  NestingDepthA( l4 );
2
2
gap> l1 + l2;
[ 1, 2, 6, 8, 5 ]
gap> l1 + l3;
[ [ 2, 2, 3, 4 ],, [ 6, 6, 3, 4 ] ]
gap> l2 + l4;
[ , [ 3, 6, 3, 4, 5 ], [ 5, 8, 3, 4, 5 ] ]
gap> l3 + l4;
[ [ 1, 2 ], [ 3, 4 ], [ 10, 12 ] ]
gap> l1 + [];
[ 1,, 3, 4 ]
\endexample


*Subtraction*

\index{list and non-list!difference}

For two {\GAP} objects $x$ and $y$ of which one is in
`IsGeneralizedRowVector' and the other is also in `IsGeneralizedRowVector'
or is neither a list nor a domain, $x - y$ is defined as $x + (-y)$.

\beginexample
gap> l1 - l2;
[ 1, -2, 0, 0, -5 ]
gap> l1 - l3;
[ [ 0, -2, 3, 4 ],, [ -4, -6, 3, 4 ] ]
gap> l2 - l4;
[ , [ -3, -2, 3, 4, 5 ], [ -5, -4, 3, 4, 5 ] ]
gap> l3 - l4;
[ [ 1, 2 ], [ -3, -4 ], [ 0, 0 ] ]
gap> l1 - [];
[ 1,, 3, 4 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Multiplicative Arithmetic for Lists}

In this general context, we define the results of multiplicative operations
only in the following situations.
For unary operations (one and inverse),
the unique argument must be in `IsMultiplicativeGeneralizedRowVector';
for binary operations (multiplication and division),
at least one argument must be in `IsMultiplicativeGeneralizedRowVector',
and the other either not a list or also in
`Is\-Multiplicative\-Generalized\-Row\-Vector'.

(For non-list {\GAP} objects, defining the results of unary operations is not
an issue here, and if at least one argument is a list not in
`IsMultiplicativeGeneralizedRowVector',
it shall be left to this argument whether the result in question is defined
and what it is.)


*One*

The one (see~"One") of a dense list $x$ in
`IsMultiplicativeGeneralizedRowVector' such that $x$ has even multiplicative
nesting depth and has the same length as each of its rows is defined
as the usual identity matrix on the outer two levels,
that is, an identity matrix of the same dimensions, with diagonal entries
$`One'( x[1][1] )$ and off-diagonal entries $`Zero'( x[1][1] )$.

\beginexample
gap> One( [ [ 1, 2 ], [ 3, 4 ] ] );
[ [ 1, 0 ], [ 0, 1 ] ]
gap> One( [ [ [ [ 1 ] ], [ [ 2 ] ] ], [ [ [ 3 ] ], [ [ 4 ] ] ] ] );
[ [ [ [ 1 ] ], [ [ 0 ] ] ], [ [ [ 0 ] ], [ [ 1 ] ] ] ]
\endexample


*Inverse*

The inverse (see~"Inverse") of an invertible square table $x$ in
`IsMultiplicativeGeneralizedRowVector' whose entries lie in a common field
is defined as the usual inverse $y$, i.e.,
a square matrix over the same field such that $x y$ and $y x$ is equal to
$`One'( x )$.

\beginexample
gap> Inverse( [ [ 1, 2 ], [ 3, 4 ] ] );
[ [ -2, 1 ], [ 3/2, -1/2 ] ]
\endexample


*Multiplication*

\index{list and non-list!product}

There are three possible computations that might be triggered by a
multiplication involving a list in `IsMultiplicativeGeneralizedRowVector'.
Namely, $x * y$ might be
\beginlist
\item{(I)}
    the inner product $x[1] * y[1] + x[2] * y[2] + \cdots + x[n] * y[n]$,
    where summands are omitted for which the entry in $x$ or $y$ is unbound
    (if this leaves no summand then the multiplication is an error),
    or
\item{(L)}
    the left scalar multiple, i.e., a list whose entry at position $i$ is
    $x * y[i]$ if $y$ is bound at position $i$, and is unbound if not, or
\item{(R)}
    the right scalar multiple, i.e., a list whose entry at position $i$ is
    $x[i] * y$ if $x$ is bound at position $i$, and is unbound if not.
\endlist

Our aim is to generalize the basic arithmetic of simple row vectors and
matrices, so we first summarize the situations that shall be covered.

\begintt
    | scl   vec   mat
---------------------
scl |       (L)   (L)
vec | (R)   (I)   (I)
mat | (R)   (R)   (R)
\endtt

This means for example that the product of a scalar (scl) with a vector (vec)
or a matrix (mat) is computed according to (L).
Note that this is asymmetric.

Now we can state the general multiplication rules.

If exactly one argument is in `IsMultiplicativeGeneralizedRowVector'
then we regard the other argument (which is then neither a list nor a domain)
as a scalar, and specify result (L) or (R), depending on ordering.

In the remaining cases, both $x$ and $y$ are in
`IsMultiplicativeGeneralizedRowVector', and we distinguish the possibilities
by their multiplicative nesting depths.
An argument with *odd* multiplicative nesting depth is regarded as a vector,
and an argument with *even* multiplicative nesting depth is regarded as a
scalar or a matrix.

So if both arguments have odd multiplicative nesting depth,
we specify result (I).

If exactly one argument has odd nesting depth,
the other is treated as a scalar if it has lower multiplicative nesting
depth, and as a matrix otherwise.
In the former case, we specify result (L) or (R), depending on ordering;
in the latter case, we specify result (L) or (I), depending on ordering.

We are left with the case that each argument has even multiplicative
nesting depth.
% By definition, this depth is nonzero.
If the two depths are equal, we treat the computation as a matrix product,
and specify result (R).
Otherwise, we treat the less deeply nested argument as a scalar and the other
as a matrix, and specify result (L) or (R), depending on ordering.

\beginexample
gap> [ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ] * (1,4);
[ (1,4), (1,4)(2,3), (1,2,4), (1,2,3,4), (1,3,2,4), (1,3,4) ]
gap> [ 1, 2, , 4 ] * 2;
[ 2, 4,, 8 ]
gap> [ 1, 2, 3 ] * [ 1, 3, 5, 7 ];
22
gap> m:= [ [ 1, 2 ], 3 ];;  m * m;
[ [ 7, 8 ], [ [ 3, 6 ], 9 ] ]
gap> m * m = [ m[1] * m, m[2] * m ];
true
gap> n:= [ 1, [ 2, 3 ] ];;  n * n;
14
gap> n * n = n[1] * n[1] + n[2] * n[2];
true
\endexample


*Division*

\index{list and non-list!quotient}

For two {\GAP} objects $x$ and $y$ of which one is in
`IsMultiplicativeGeneralizedRowVector' and the other is also in
`IsMultiplicativeGeneralizedRowVector' or is neither a list nor a domain,
$x / y$ is defined as $x * y^{-1}$.

\beginexample
gap> [ 1, 2, 3 ] / 2;  [ 1, 2 ] / [ [ 1, 2 ], [ 3, 4 ] ];
[ 1/2, 1, 3/2 ]
[ 1, 0 ]
\endexample


*mod*

\index{list and non-list!mod}
\index{mod!lists}

If $x$ and $y$ are in `IsMultiplicativeGeneralizedRowVector' and have the
same multiplicative nesting depth (see~"NestingDepthM"),
% By definition, this depth is nonzero.
$x `mod'  y$ is defined *pointwise*, in the sense that the result is a
list whose entry at position $i$ is $x[i] `mod' y[i]$ if these entries are
bound,
is a shallow copy (see~"ShallowCopy") of $x[i]$ or $y[i]$ if the other
argument is not bound at position $i$,
and is unbound if both $x$ and $y$ are unbound at position $i$.

If $x$ is in `IsMultiplicativeGeneralizedRowVector' and $y$ is in
`Is\-Multiplicative\-Generalized\-Row\-Vector' and has lower multiplicative
nesting depth or is neither a list nor a domain,
$x `mod' y$ is defined as a list whose entry at position $i$ is
$x[i] `mod' y$ if $x$ is bound at position $i$, and is unbound if not.
The equivalent holds in the reversed case,
where the order of the arguments is kept.

\beginexample
gap> 4711 mod [ 2, 3,, 5, 7 ];
[ 1, 1,, 1, 0 ]
gap> [ 2, 3, 4, 5, 6 ] mod 3;
[ 2, 0, 1, 2, 0 ]
gap> [ 10, 12, 14, 16 ] mod [ 3, 5, 7 ];
[ 1, 2, 0, 16 ]
\endexample


*Left Quotient*

\index{list and non-list!left quotient}

For two {\GAP} objects $x$ and $y$ of which one is in
`IsMultiplicativeGeneralizedRowVector' and the other is also in
`IsMultiplicativeGeneralizedRowVector' or is neither a list nor a domain,
$`LeftQuotient'( x, y )$ is defined as $x^{-1} * y$.

\beginexample
gap> LeftQuotient( [ [ 1, 2 ], [ 3, 4 ] ], [ 1, 2 ] );
[ 0, 1/2 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Mutability Status and List Arithmetic}

Many results of arithmetic operations, when applied to lists,
are again lists, and it is of interest whether their entries are mutable
or not (if applicable).
Note that the mutability status of the result itself is already defined
by the general rule for any result of an arithmetic operation, not
only for lists (see~"Mutability and Copyability").

However, we do *not* define exactly the mutability status for each element
on each level of a nested list returned by an arithmetic operation.
(Of course it would be possible to define this recursively,
but since the methods used are in general not recursive,
in particular for efficient multiplication of compressed matrices,
such a general definition would be a burden in these cases.)
Instead we consider, for a list $x$ in `IsGeneralizedRowVector',
the sequence $x = x_1, x_2, \ldots x_n$ where $x_{i+1}$ is the first bound
entry in $x_i$ if exists (that is, if $x_i$ is a nonempty list),
and $n$ is the largest $i$ such that $x_i$ lies in `IsGeneralizedRowVector'.
The *immutability level* of $x$ is defined as infinity if $x$ is immutable,
and otherwise the number of $x_i$ which are immutable.
(So the immutability level of a mutable empty list is $0$.)

Thus a fully mutable matrix has immutability level $0$,
and a mutable matrix with immutable first row has immutability level $1$
(independent of the mutability of other rows).

The immutability level of the result of any of the binary operations
discussed here is the minimum of the immutability levels of the arguments,
provided that objects of the required mutability status exist in {\GAP}.
% Note that this means to call `ShallowCopy' more often than necessary!
% Would it be possible to promise the mutability status for all entries only
% if the arguments are homogeneously mutable,
% as a refinement of the general mutability rule?

Moreover, the results have a ``homogeneous'' mutability status,
that is, if the first bound entry at nesting depth $i$ is immutable (mutable)
then all entries at nesting depth $i$ are immutable (mutable, provided that
a mutable version of this entry exists in {\GAP}).

Thus the sum of two mutable matrices whose first rows are mutable
is a matrix all of whose rows are mutable,
and the product of two matrices whose first rows are immutable
is a matrix all of whose rows are immutable,
independent of the mutability status of the other rows of the arguments.

% Note that there are situations where this rule (and in fact already the
% general rule mentioned above) leads to counter-intuitive results.

For example, the sum of a matrix (mutable or immutable, i.e.,
of immutability level one of $0$, $1$, or $2$) and a mutable row vector
(i.e., immutability level $0$) is a fully mutable matrix.
The product of two mutable row vectors of integers is an integer,
and since {\GAP} does not support mutable integers, the result is immutable.

For unary arithmetic operations, there are three operations available,
an attribute that returns an immutable result
(`Zero', `AdditiveInverse', `One', `Inverse'),
an operation that returns a result that is mutable
% at least on the outer level, or shall more be guaranteed?
(`ZeroOp', `AdditiveInverseOp', `OneOp', `InverseOp'),
and an operation whose result has the same immutability level as the argument
(`ZeroSM', `AdditiveInverseSM', `OneSM', `InverseSM').
The last kind of operations is equivalent to the corresponding infix
operations `0 * <list>', `- <list>', `<list>^0', and `<list>^-1'.
(This holds not only for lists, see~"Mutability and Copyability".)

\beginexample
gap> IsMutable( l1 );  IsMutable( 2 * Immutable( [ 1, 2, 3 ] ) );
true
false
gap> IsMutable( l2 );  IsMutable( l3 );
true
true
\endexample

An example motivating the mutability rule is the use of syntactic constructs
such as `<obj> \* <list>' and `- <list>' as an elegant and efficient way to
create mutable lists needed for further manipulations from mutable lists.
In particular one can construct a mutable zero vector of length <n>
by `0 \* [ 1 .. <n> ]'.
The latter can be done also using `ListWithIdenticalEntries'.

\Declaration{ListWithIdenticalEntries}
\beginexample
gap> ListWithIdenticalEntries( 10, 0 );
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Finding Positions in Lists}

\Declaration{Position}
\beginexample
gap> Position( [ 2, 2, 1, 3 ], 1 );
3
gap> Position( [ 2, 1, 1, 3 ], 1 );
2
gap> Position( [ 2, 1, 1, 3 ], 1, 2 );
3
gap> Position( [ 2, 1, 1, 3 ], 1, 3 );
fail
\endexample

\Declaration{PositionCanonical}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;u:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);;
gap> rt:=RightTransversal(g,u);;AsList(rt);
[ (), (3,4), (2,3), (2,3,4), (2,4,3), (2,4) ]
gap> Position(rt,(1,2));
fail
gap> PositionCanonical(rt,(1,2));
2
\endexample


\Declaration{PositionNthOccurrence}
\beginexample
gap> PositionNthOccurrence([1,2,3,2,4,2,1],1,1);
1
gap> PositionNthOccurrence([1,2,3,2,4,2,1],1,2);
7
gap> PositionNthOccurrence([1,2,3,2,4,2,1],2,3);
6
gap> PositionNthOccurrence([1,2,3,2,4,2,1],2,4);
fail
\endexample

\Declaration{PositionSorted}
\beginexample
gap> PositionSorted( [1,4,5,5,6,7], 0 );
1
gap> PositionSorted( [1,4,5,5,6,7], 2 );
2
gap> PositionSorted( [1,4,5,5,6,7], 4 );
2
gap> PositionSorted( [1,4,5,5,6,7], 5 );
3
gap> PositionSorted( [1,4,5,5,6,7], 8 );
7
\endexample

\Declaration{PositionSet}
\beginexample
gap> PositionSet( [1,4,5,5,6,7], 0 );
fail
gap> PositionSet( [1,4,5,5,6,7], 2 );
fail
gap> PositionSet( [1,4,5,5,6,7], 4 );
2
gap> PositionSet( [1,4,5,5,6,7], 5 );
3
gap> PositionSet( [1,4,5,5,6,7], 8 );
fail
\endexample

\Declaration{PositionProperty}
\beginexample
gap> PositionProperty( [10^7..10^8], IsPrime );
20
gap> PositionProperty( [10^5..10^6],
>        n -> not IsPrime(n) and IsPrimePowerInt(n) );
490
\endexample
`First' (see~"First") allows you to extract the first element of a list
that satisfies a certain property.

\Declaration{PositionBound}
\beginexample
gap> PositionBound([1,2,3]);
1
gap> PositionBound([,1,2,3]);
2
\endexample

\Declaration{PositionNot}
\Declaration{PositionNonZero}
\beginexample
gap> l:= [ 1, 1, 2, 3, 2 ];;  PositionNot( l, 1 );
3
gap> PositionNot( l, 1, 4 );  PositionNot( l, 2, 5 );
5
6
gap> PositionNonZero( l );  PositionNonZero( [ 2, 3, 4, 5 ] * Z(2) );
1
2
\endexample

\Declaration{PositionSublist}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties and Attributes for Lists}

\Declaration{IsMatchingSublist}

*Note:* A list that contains mutable objects (like lists or records)
*cannot* store attribute values that depend on the values of its entries,
such as whether it is homogeneous, sorted, or strictly sorted,
as changes in any of its entries could change such property values,
like the following example shows.
\beginexample
gap> l:=[[1],[2]];
[ [ 1 ], [ 2 ] ]
gap> IsSSortedList(l);
true
gap> l[1][1]:=3;
3
gap> IsSSortedList(l);
false
\endexample
For such lists these property values must be computed anew
each time the property is asked for.
For example, if <list> is a list of mutable row vectors then the call of
`Position' (see~"Position") with <list> as first argument
cannot take advantage of the fact that <list> is in fact sorted.
One solution is to call explicitly `PositionSorted' (see~"PositionSorted")
in such a situation, another solution is to replace <list> by an immutable
copy using `Immutable' (see~"Mutability and Copyability").

\Declaration{IsDuplicateFree}
\Declaration{IsSortedList}
\Declaration{IsSSortedList}
\Declaration{Length}
\Declaration{ConstantTimeAccessList}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sorting Lists}

\Declaration{Sort}
\beginexample
gap> list := [ 5, 4, 6, 1, 7, 5 ];; Sort( list ); list;
[ 1, 4, 5, 5, 6, 7 ]
gap> list := [ [0,6], [1,2], [1,3], [1,5], [0,4], [3,4] ];;
gap> Sort( list, function(v,w) return v*v < w*w; end ); list;
[ [ 1, 2 ], [ 1, 3 ], [ 0, 4 ], [ 3, 4 ], [ 1, 5 ], [ 0, 6 ] ]
  # sorted according to the Euclidian distance from [0,0]
gap> list := [ [0,6], [1,3], [3,4], [1,5], [1,2], [0,4], ];;
gap> Sort( list, function(v,w) return v[1] < w[1]; end ); list;
[ [ 0, 6 ], [ 0, 4 ], [ 1, 3 ], [ 1, 5 ], [ 1, 2 ], [ 3, 4 ] ]
  # note the random order of the elements with equal first component
\endexample

\Declaration{SortParallel}
\beginexample
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := [ 2, 3, 5, 7, 8, 9 ];;
gap> SortParallel( list1, list2 );
gap> list1;
[ 1, 4, 5, 5, 6, 7 ]
gap> list2;
[ 7, 3, 2, 9, 5, 8 ]  # [ 7, 3, 9, 2, 5, 8 ] is also possible
\endexample

\Declaration{Sortex}
\beginexample
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := ShallowCopy( list1 );;
gap> perm := Sortex( list1 );
(1,3,5,6,4)
gap> list1;
[ 1, 4, 5, 5, 6, 7 ]
gap> Permuted( list2, perm );
[ 1, 4, 5, 5, 6, 7 ]
\endexample

\Declaration{SortingPerm}
\beginexample
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := ShallowCopy( list1 );;
gap> perm := SortingPerm( list1 );
(1,3,5,6,4)
gap> list1;
[ 5, 4, 6, 1, 7, 5 ]
gap> Permuted( list2, perm );
[ 1, 4, 5, 5, 6, 7 ]
\endexample

Currently {\GAP} uses shellsort.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sorted Lists and Sets}

\index{sets}
\index{multisets}

Searching objects in a list works much quicker if the list is known to be
sorted.
Currently {\GAP} exploits the sortedness of a list automatically only if
the list is *strictly sorted*, which is indicated by the property
`IsSSortedList', see~"IsSSortedList".

Remember that a list of *mutable* objects cannot store that it is strictly
sorted but has to test it anew whenever it is asked whether it is sorted,
see the remark in~"Properties and Attributes for Lists".
Therefore {\GAP} cannot take advantage of the sortedness of a list if this
list has mutable entries.
Moreover, if a sorted list <list> with mutable elements is used as an argument
of a function that *expects* this argument to be sorted,
for example `UniteSet' or `RemoveSet' (see~"UniteSet", "RemoveSet"),
then it is checked whether <list> is in fact sorted;
this check can have the effect actually to slow down the computations,
compared to computations with sorted lists of immutable elements
or computations that do not involve functions that do automatically check
sortedness.

Strictly sorted lists are used to represent *sets* in {\GAP}.
More precisely, a strictly sorted list is called a *proper set*
in the following, in order to avoid confusion with domains (see~"Domains")
which also represent sets.

In short proper sets are represented by sorted lists without holes and
duplicates in {\GAP}.
Note that we guarantee this representation, so  you may make use of
the fact that a set is represented by a sorted list in your functions.

In some contexts (for example see~"Combinatorics"), we also want to talk
about multisets.
A *multiset* is like a set, except that an element may appear several times
in a multiset.
Such multisets are represented by sorted lists without holes
that may have duplicates.

This section lists only those functions that are defined exclusively for
proper sets.
Set theoretic functions for general collections, such as `Intersection'
and `Union', are described in Chapter~"Collections".
In particular, for the construction of proper sets, see~"SSortedList"
and "AsSSortedList".
For finding positions in sorted lists, see~"PositionSorted".


\>`<obj> in <list>'{in!for strictly sorted lists}@{`in'!for strictly sorted lists}

The element test for strictly sorted lists uses binary search.


\FileHeader{set}[1]

\Declaration{IsEqualSet}
\index{test!for set equality}
\beginexample
gap> IsEqualSet( [2,3,5,7,11], [11,7,5,3,2] );
true
gap> IsEqualSet( [2,3,5,7,11], [2,3,5,7,11,13] );
false
\endexample

\Declaration{IsSubsetSet}

\Declaration{AddSet}
\index{add!an element to a set}
\beginexample
gap> s := [2,3,7,11];;
gap> AddSet( s, 5 );  s;
[ 2, 3, 5, 7, 11 ]
gap> AddSet( s, 13 );  s;
[ 2, 3, 5, 7, 11, 13 ]
gap> AddSet( s, 3 );  s;
[ 2, 3, 5, 7, 11, 13 ]
\endexample

\Declaration{RemoveSet}
\index{remove!an element from a set}
\beginexample
gap> s := [ 2, 3, 4, 5, 6, 7 ];;
gap> RemoveSet( s, 6 ); s;
[ 2, 3, 4, 5, 7 ]
gap> RemoveSet( s, 10 ); s;
[ 2, 3, 4, 5, 7 ]
\endexample

\Declaration{UniteSet}
\index{union!of sets}
\beginexample
gap> set := [ 2, 3, 5, 7, 11 ];;
gap> UniteSet( set, [ 4, 8, 9 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11 ]
gap> UniteSet( set, [ 16, 9, 25, 13, 16 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 25 ]
\endexample

\Declaration{IntersectSet}
\index{intersection!of sets}
\beginexample
gap> set := [ 2, 3, 4, 5, 7, 8, 9, 11, 13, 16 ];;
gap> IntersectSet( set, [ 3, 5, 7, 9, 11, 13, 15, 17 ] );  set;
[ 3, 5, 7, 9, 11, 13 ]
gap> IntersectSet( set, [ 9, 4, 6, 8 ] );  set;
[ 9 ]
\endexample

\Declaration{SubtractSet}
\index{subtract!a set from another}
\beginexample
gap> set := [ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];;
gap> SubtractSet( set, [ 6, 10 ] );  set;
[ 2, 3, 4, 5, 7, 8, 9, 11 ]
gap> SubtractSet( set, [ 9, 4, 6, 8 ] );  set;
[ 2, 3, 5, 7, 11 ]
\endexample

There are nondestructive counterparts of the functions `UniteSet',
`IntersectSet', and `SubtractSet' available for proper sets.
These are `UnionSet', `IntersectionSet', and `Difference'.
The former two are methods for the more general operations `Union'
and `Intersection' (see~"Union", "Intersection"),
the latter is itself an operation (see~"Difference").

The result of `IntersectionSet' and `UnionSet' is always a new list,
that is not identical to any other list.
The elements of that list however are identical to the corresponding
elements of the first argument <set>.
If <set> is not a proper set it is not specified to which of a number
of equal elements in <set> the element in the result is identical
(see~"Identical Lists").

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % (from the GAP 3.4 manual)
% \Section{More about Sets}
% 
% In the previous section we defined a proper  set as a sorted list without
% holes or duplicates.  This representation is not  only nice to use, it is
% also a good internal representation supporting efficient algorithms.  For
% example the `in' operator can use binary instead of a linear search since
% a set is sorted.  For another example `Union' only has to merge the sets.
% 
% However, all  those set functions  also allow lists that are  not  proper
% sets,  silently making  a copy  of it and  converting this copy to a set.
% Suppose all the functions would have to test  their arguments every time,
% comparing  each element  with its  successor, to see if  they  are proper
% sets.  This would chew up most  of  the performance advantage again.  For
% example suppose `in' would have to run  over the whole list, to see if it
% is  a  proper set, so  it could  use the  binary search.   That  would be
% ridiculous.
% 
% To avoid this a  list that is  a proper set  may, but need  not, have  an
% internal flag set that tells  those functions that  this list is indeed a
% proper set.  Those functions do not have to check this argument then, and
% can use the more  efficient algorithms.  This  section tells  you  when a
% proper set obtains this flag,  so you can write your  functions in such a
% way that you make best use of the algorithms.
% 
% The results of `Set', `Difference', `Intersection'  and `Union' are known
% to be sets by construction, and thus have the flag set upon creation.
% 
% If an argument to `IsSet', `IsEqualSet', `IsSubset', `Set', `Difference',
% `Intersection' or  `Union' is a proper  set, that does  not  yet have the
% flag set, those functions will notice that and set the flag for this set.
% Note that `in' will use linear search if the  right operand does not have
% the flag set, will therefore not detect  if it is  a proper set and will,
% unlike the functions above, never set the flag.
% 
% If you change a proper set, that does have this  flag set, by assignment,
% `Add'   or `Append' the  set  will generally lose  it  flag,  even if the
% change is such that the resulting list is still a proper set.  However if
% the set has more than 100 elements and the value assigned or added is not
% a list and not a record and the resulting list is still a proper set than
% it will keep  the flag.  Note that  changing a list  that is not a proper
% set will never set the flag, even if the resulting list  is a proper set.
% Such a set will obtain the flag only if it is passed to a set function.
% 
% Suppose you have built a proper set  in such a way that  it does not have
% the flag set, and that you now want  to perform lots of membership tests.
% Then you  should call `IsSet'  with that set   as an argument.   If it is
% indeed  a proper set  `IsSet' will set the flag,  and the subsequent `in'
% operations will use  the more efficient binary  search.  You can think of
% the call to `IsSet' as a hint to {\GAP} that this list is a proper set.
% 
% There is no way you can set the flag for an ordinary  list  without going
% through the checking in `IsSet'.  The  internal  functions depend so much
% on the fact that a list with  this flag set  is indeed sorted and without
% holes and duplicates that the risk would be too high to allow setting the
% flag without such a check.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Lists}

Several of the following functions expect the first argument to be either a
list or a collection (see~"Collections"), with possibly slightly different
meaning for lists and non-list collections.
For these functions, the list case is indicated by an argument named <list>,
and the collection case by one named <C>.

\Declaration{Concatenation}
\index{concatenation!of lists}
\beginexample
gap> Concatenation( [ 1, 2, 3 ], [ 4, 5 ] );
[ 1, 2, 3, 4, 5 ]
gap> Concatenation( [2,3,,5,,7], [11,,13,,,,17,,19] );
[ 2, 3,, 5,, 7, 11,, 13,,,, 17,, 19 ]
gap> Concatenation( [ [1,2,3], [2,3,4], [3,4,5] ] );
[ 1, 2, 3, 2, 3, 4, 3, 4, 5 ]
\endexample

\Declaration{Compacted}
\beginexample
gap> l:=[,1,,,3,,,4,[5,,,6],7];;  Compacted( l );
[ 1, 3, 4, [ 5,,, 6 ], 7 ]
\endexample

\Declaration{Collected}
\beginexample
gap> Factors( Factorial( 10 ) );
[ 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5, 7 ]
gap> Collected( last );
[ [ 2, 8 ], [ 3, 4 ], [ 5, 2 ], [ 7, 1 ] ]
gap> Collected( last );
[ [ [ 2, 8 ], 1 ], [ [ 3, 4 ], 1 ], [ [ 5, 2 ], 1 ], [ [ 7, 1 ], 1 ] ]
\endexample

\Declaration{DuplicateFreeList}
\beginexample
gap> l:=[1,Z(3),1,"abc",Group((1,2,3),(1,2)),Z(3),Group((1,2),(2,3))];;
gap> DuplicateFreeList( l );
[ 1, Z(3), "abc", Group([ (1,2,3), (1,2) ]) ]
\endexample

\Declaration{AsDuplicateFreeList}

\Declaration{Flat}
\beginexample
gap> Flat( [ 1, [ 2, 3 ], [ [ 1, 2 ], 3 ] ] );
[ 1, 2, 3, 1, 2, 3 ]
gap> Flat( [ ] );
[  ]
\endexample
(To reconstruct a matrix from a `Flat'tened list, the sublist operator can
be used:
\beginexample
gap> l:=[9..14];;w:=2;; # w is the length of each row
gap> sub:=[1..w];;List([1..Length(l)/w],i->l{(i-1)*w+sub});
[ [ 9, 10 ], [ 11, 12 ], [ 13, 14 ] ]
\endexample
)

\Declaration{Reversed}
\beginexample
gap> Reversed( [ 1, 4, 9, 5, 6, 7 ] );
[ 7, 6, 5, 9, 4, 1 ]
\endexample

\Declaration{IsLexicographicallyLess}

\Declaration{Apply}
\beginexample
gap> l:= [ 1, 2, 3 ];;  Apply( l, i -> i^2 );  l;
[ 1, 4, 9 ]
\endexample

\Declaration{PermListList}
\beginexample
gap> list1 := [ 5, 4, 6, 1, 7, 5 ];;
gap> list2 := [ 4, 1, 7, 5, 5, 6 ];;
gap> perm := PermListList(list1, list2);
(1,2,4)(3,5,6)
gap> Permuted( list2, perm );
[ 5, 4, 6, 1, 7, 5 ]
\endexample

\Declaration{Maximum}
\beginexample
gap> Maximum( -123, 700, 123, 0, -1000 );
700
gap> Maximum( [ -123, 700, 123, 0, -1000 ] );
700
gap> Maximum( [ 1, 2 ], [ 0, 15 ], [ 1, 5 ], [ 2, -11 ] );
[ 2, -11 ]        # lists are compared elementwise
\endexample

\Declaration{Minimum}
\beginexample
gap> Minimum( -123, 700, 123, 0, -1000 );
-1000
gap> Minimum( [ -123, 700, 123, 0, -1000 ] );
-1000
gap> Minimum( [ 1, 2 ], [ 0, 15 ], [ 1, 5 ], [ 2, -11 ] );
[ 0, 15 ]
\endexample

\Declaration{MaximumList}

\Declaration{Cartesian}
\beginexample
gap> Cartesian( [1,2], [3,4], [5,6] );
[ [ 1, 3, 5 ], [ 1, 3, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
  [ 2, 3, 6 ], [ 2, 4, 5 ], [ 2, 4, 6 ] ]
gap> Cartesian( [1,2,2], [1,1,2] );
[ [ 1, 1 ], [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 1 ], [ 2, 2 ], [ 2, 1 ], 
  [ 2, 1 ], [ 2, 2 ] ]
\endexample

\Declaration{Permuted}
\beginexample
gap> Permuted( [ 5, 4, 6, 1, 7, 5 ], (1,3,5,6,4) );
[ 1, 4, 5, 5, 6, 7 ]
\endexample

\Declaration{List}
\beginexample
gap> List( [1,2,3], i -> i^2 );
[ 1, 4, 9 ]
gap> List( [1..10], IsPrime );
[ false, true, true, false, true, false, true, false, false, false ]
\endexample

\Declaration{Filtered}
\beginexample
gap> Filtered( [1..20], IsPrime );
[ 2, 3, 5, 7, 11, 13, 17, 19 ]
gap> Filtered( [ 1, 3, 4, -4, 4, 7, 10, 6 ], IsPrimePowerInt );
[ 3, 4, 4, 7 ]
gap> Filtered( [ 1, 3, 4, -4, 4, 7, 10, 6 ],
>              n -> IsPrimePowerInt(n) and n mod 2 <> 0 );
[ 3, 7 ]
gap> Filtered( Group( (1,2), (1,2,3) ), x -> Order( x ) = 2 );
[ (2,3), (1,2), (1,3) ]
\endexample

\Declaration{Number}
\beginexample
gap> Number( [ 2, 3, 5, 7 ] );
4
gap> Number( [, 2, 3,, 5,, 7,,,, 11 ] );
5
gap> Number( [1..20], IsPrime );
8
gap> Number( [ 1, 3, 4, -4, 4, 7, 10, 6 ], IsPrimePowerInt );
4
gap> Number( [ 1, 3, 4, -4, 4, 7, 10, 6 ],
>            n -> IsPrimePowerInt(n) and n mod 2 <> 0 );
2
gap> Number( Group( (1,2), (1,2,3) ), x -> Order( x ) = 2 );
3
\endexample

\Declaration{First}
\beginexample
gap> First( [10^7..10^8], IsPrime );
10000019
gap> First( [10^5..10^6],
>      n -> not IsPrime(n) and IsPrimePowerInt(n) );
100489
gap> First( [ 1 .. 20 ], x -> x < 0 );
fail
gap> First( [ fail ], x -> x = fail );
fail
\endexample

\Declaration{ForAll}
\beginexample
gap> ForAll( [1..20], IsPrime );
false
gap> ForAll( [2,3,4,5,8,9], IsPrimePowerInt );
true
gap> ForAll( [2..14], n -> IsPrimePowerInt(n) or n mod 2 = 0 );
true
gap> ForAll( Group( (1,2), (1,2,3) ), i -> SignPerm(i) = 1 );
false
\endexample

\Declaration{ForAny}
\beginexample
gap> ForAny( [1..20], IsPrime );
true
gap> ForAny( [2,3,4,5,8,9], IsPrimePowerInt );
true
gap> ForAny( [2..14],
>    n -> IsPrimePowerInt(n) and n mod 5 = 0 and not IsPrime(n) );
false
gap> ForAny( Integers, i ->     i > 0
>                           and ForAll( [0,2..4], j -> IsPrime(i+j) ) );
true
\endexample

\Declaration{Product}
\beginexample
gap> Product( [ 2, 3, 5, 7, 11, 13, 17, 19 ] );
9699690
gap> Product( [1..10], x->x^2 );
13168189440000
gap> Product( [ (1,2), (1,3), (1,4), (2,3), (2,4), (3,4) ] );
(1,4)(2,3)
gap> Product( GF(8) );
0*Z(2)
\endexample

\Declaration{Sum}
\beginexample
gap> Sum( [ 2, 3, 5, 7, 11, 13, 17, 19 ] );
77
gap> Sum( [1..10], x->x^2 );
385
gap> Sum( [ [1,2], [3,4], [5,6] ] );
[ 9, 12 ]
gap> Sum( GF(8) );
0*Z(2)
\endexample

\Declaration{Iterated}
\beginexample
gap> Iterated( [ 126, 66, 105 ], Gcd );
3
\endexample

\Declaration{ListN}
\beginexample
gap> ListN( [1,2], [3,4], \+ );
[ 4, 6 ]
\endexample




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Advanced List Manipulations}

The following functions are generalizations of `List' (see~"List"),
`Set' (see~"Set"), `Sum' (see~"Sum"), and `Product' (see~"Product").

\Declaration{ListX}
\Declaration{SetX}
\Declaration{SumX}
\Declaration{ProductX}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Ranges}

\index{range}
A *range* is a dense list of integers in arithmetic progression (or
degression).
This is a list of integers such that the difference between
consecutive elements is a nonzero constant.  Ranges can be abbreviated
with the syntactic construct `[ <first>, <second> .. <last> ]' or, if the
difference between consecutive elements is 1, as `[ <first> .. <last> ]'.

If `<first> > <last>', `[<first>..<last>]' is the empty  list,  which  by
definition is also a range; also, if `<second> >  <first>  >  <last>'  or
`<second> \< <first> \< <last>', then `[<first>,<second>..<last>]' is the
empty list. If `<first>  =  <last>',  `[<first>,<second>..<last>]'  is  a
singleton list, which is a range, too. Note that `<last> - <first>'  must
be divisible by the increment `<second> - <first>', otherwise an error is
signalled.

Note also that a range is just a special case of a list.
Thus you can access elements in a range (see "List Elements"), test for
membership etc.
You can even assign to such a range if it is mutable (see~"List Assignment").
Of course, unless you assign `<last> + <second>-<first>' to the entry
`<range>[Length(<range>)+1]', the resulting list will no longer be a range.

\beginexample
gap> r := [10..20];
[ 10 .. 20 ]
gap> Length( r );
11
gap> r[3];
12
gap> 17 in r;
true
gap> r[12] := 25;; r;
[ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25 ]  # is no longer a range
gap> r := [1,3..17];
[ 1, 3 .. 17 ]
gap> Length( r );
9
gap> r[4];
7
gap> r := [0,-1..-9];
[ 0, -1 .. -9 ]
gap> r[5];
-4
gap> r := [ 1, 4 .. 32 ];
Range: <last>-<first> (31) must be divisible by <inc> (3)
\endexample

Most often ranges are used in connection with the `for'-loop (see~"For").
Here the construct

`for <var>  in [<first>..<last>]  do <statements>  od'

replaces the

`for <var>  from <first>  to <last>  do <statements>  od'

which is more usual in other programming languages.

\beginexample
gap> s := [];; for i in [10..20] do Add( s, i^2 ); od; s;
[ 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400 ]
\endexample

Note that a range with `<last> >= <first>' is at the same time also a
proper set (see~"Sorted Lists and Sets"),
because it contains no holes or duplicates and is sorted,
and also a row vector (see~"Row Vectors"),
because it contains no holes and all elements are integers.

\Declaration{IsRange}
\beginexample
gap> IsRange( [1,2,3] );  IsRange( [7,5,3,1] );
true
true
gap> IsRange( [1,2,4,5] );  IsRange( [1,,3,,5,,7] );
false
false
gap> IsRange( [] );  IsRange( [1] );
true
true
\endexample

\Declaration{ConvertToRangeRep}
\beginexample
gap> r:= [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
gap> ConvertToRangeRep( r );  r;
[ 1 .. 10 ]
gap> l:= [ 1, 2, 4, 5 ];;  ConvertToRangeRep( l );  l;
[ 1, 2, 4, 5 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Enumerators}

An *enumerator* is an immutable list that need not store its elements
explicitly but knows, from a set of basic data, how to determine the $i$-th
element and the position of a given object.
A typical example of this is a vector space over a finite field with $q$
elements, say, for which it is very easy to enumerate all elements
using $q$-adic expansions of integers.

Using this enumeration can be even quicker than a binary search in a sorted
list of vectors:

\Declaration{IsQuickPositionList}

On the one hand, element access to an enumerator may take more time than
element access to an internally represented list containing the same
elements.
On the other hand, an enumerator may save a vast amount of memory.
Take for example a permutation group of size a few millions.
Even for moderate degree it is unlikely that a list of all its elements
will fit into memory whereas it is no problem to construct an enumerator
from a stabilizer chain (see~"Stabilizer Chains").

There are situations where one only wants to loop over the elements of a
domain, without using the special facilities of an enumerator,
namely the particular order of elements and the possibility to find the
position of elements.
For such cases, {\GAP} provides iterators (see~"Iterators").

For constructing enumerators, see~"Enumerator" and "EnumeratorSorted".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

