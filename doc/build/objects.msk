%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  objects.msk              GAP manual                     Thomas Breuer
%W                                                       Martin Schoenert
%%
%H  @(#)$Id$
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Objects and Elements}

An *object* is everything in {\GAP} that can be assigned to a variable,
so nearly everything in {\GAP} is an object.

Different objects can be regarded as equal with respect to the equivalence
relation `{`='}',
in this case we say that the objects describe the same *element*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Objects}

Nearly all things one deals with in {\GAP} are *objects*.
For example, an integer is an object, as is a list of integers, a matrix,
a permutation, a function, a list of functions, a group,
a coset or a conjugacy class in a group.

Examples of things that are not objects are
comments which are only lexical constructs,
`while' loops which are only syntactical constructs,
and expressions, such as `1 + 1';
but note that the value of an expression, in this case the integer `2',
is an object.

Objects can be assigned to variables,
and everything that can be assigned to a variable is an object.
Analogously, objects can be used as arguments of functions.

\Declaration{IsObject}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements}

The equality operation ``{`='}'' defines an equivalence relation on all
{\GAP} objects.
The equivalence classes are called *elements*.

There are basically three reasons to regard different objects as equal.
First, the same information may be stored in different places.
Second, the same information may be stored in different ways;
for example, a polynomial can be stored sparsely or densely.
Third, different information may be equal modulo a mathematical
equivalence relation.
For example, in a finitely presented group with the relation $a^2 = 1$
the different objects $a$ and $a^3$ describe the same element.

As an example for all three aspects, consider the possibility to store
an integer in several places of the memory,
to represent it as a fraction with denominator 1,
or to represent it as a fraction with any denominator, with numerator
a suitable multiple of it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domains}

A *domain* in {\GAP} is a structured set.
Domains are objects.

For example, every group is a domain, every conjugacy class of elements
in a group is a domain, every coset in a group is a domain.

Domains are the most important objects in {\GAP}.
In a sense, the only reason to introduce objects such as integers and
permutations in {\GAP} is the wish to form domains of them.

Domains are described in Chapter~"Domains and their Elements".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Objects}

Two objects that are equal *as objects* and not only w.r.t. the equality
relation `{`='}' are called *identical*.
So identical objects do of course describe the same element.

\>IsIdenticalObj( <obj1>, <obj2> ) F

Two objects are identical if they are stored at the same location in memory.
For two copies of a simple constant object it is
implementation-dependent whether {\GAP} will store only a single copy
in memory.

\beginexample
gap> IsIdenticalObj( 10^6, 10^6);
true
gap> IsIdenticalObj( 10^12, 10^12);
false
gap> IsIdenticalObj( true, true);
true
\endexample

Usually one may deal with objects but think of elements,
because one is not interested in places in memory, ways of storing,
and information beyond underlying equivalence relations.

But there are cases where it is important to distinguish the relations
identity and equality.
This is best illustrated with an example.
(The reader who is not familiar with lists in {\GAP}, in particular
element access and assignment, is referred to Chapter~"Lists".)
\beginexample
gap> l1:= [ 1, 2, 3 ];; l2:= [ 1, 2, 3 ];;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
false
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 3 ]
gap> l1 = l2;
false
\endexample
The two lists `l1' and `l2' are equal but not identical.
Thus a change in `l1' does not affect `l2'.
\beginexample
gap> l1:= [ 1, 2, 3 ];; l2:= l1;;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
true
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 4 ]
gap> l1 = l2;
true
\endexample
Here, `l1' and `l2' are identical objects,
so changing `l1' means to change `l2' as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Mutability and Copyability}

For many purposes, *mutable* objects are useful.
For example, mutable lists
can be changed by assigning values to positions
or by unbinding values at certain positions.
Similarly, one can assign values to components of a mutable record,
or unbind them.

In other situations, however,
one wants to ensure that certain objects are *immutable*,
i.e., that they cannot be changed.
For example, take the identity of a matrix group.
Since this matrix may be referred to as the identity of the group in several
places, it would be fatal to modify its entries, or add or unbind rows.

\Declaration{Immutable}

Note that it is *not* possible to turn an immutable object into a
mutable one;
only mutable copies can be made (see~"Duplication of Objects").

\>MakeImmutable( <obj> ) F

One can turn the (mutable or immutable) object <obj> into an immutable one
with `MakeImmutable';
note that this makes also all subobjects of <obj> immutable,
so one should call `MakeImmutable' only if <obj> and its mutable subobjects
are newly created.
If one is not sure about this, `Immutable' should be used.

Using `Immutable', it is possible to store an immutable identity matrix
or an immutable list of generators,
and to make a mutable copy whenever it is needed.
Compared to the situation without immutable objects,
much unnecessary copying is avoided this way.
Another advantage of immutability is
that lists of immutable objects may store whether they are sorted
(see~"Sorted Lists and Sets"),
which is not possible for lists of mutable objects.

Objects for which only an immutable form exists in {\GAP}
are called *constants*.
Examples of constants are integers, permutations, and domains.
Called with a constant as argument,
`Immutable' and `ShallowCopy' return this argument.

If a mutable form of an object can be made in {\GAP},
the object is called *copyable*.
Examples of copyable objects are of course lists and records.
Given an immutable matrix <mat>,
`ShallowCopy' returns a mutable matrix whose rows are identical with the
rows of <mat>.
In particular the rows are still immutable.
To get a matrix whose rows are mutable,
one can use `List( <mat>, ShallowCopy )'.

Another interesting example of mutable (and thus copyable) objects
is provided by *iterators*, see~"Iterators".
(Of course it makes no sense to create an immutable form of an iterator,
but clearly `Immutable' will yield such an object.)
Every call of `NextIterator' changes a mutable iterator until it is
exhausted, and this is the only possibility to change an iterator.
`ShallowCopy' for an iterator <iter> is defined to return a mutable iterator
that has no mutable data in common with <iter>,
and that behaves equally to <iter> w.r.t.~`IsDoneIterator' and
(if <iter> is mutable) `NextIterator'.
Note that the meaning of the ``shallow copy'' of an iterator that is
returned by `ShallowCopy' is not as obvious as for lists and records,
and must be explicitly defined.

Many operations return immutable results,
among those mainly attributes (see~"Attributes");
examples of attributes are `Zero', `AdditiveInverse', `One', and `Inverse'.
Arithmetic operations, such as the binary infix operations `+', `-', `*',
`/', `^', `mod', the unary `-', and operations such as `Comm' and
`LeftQuotient', return *mutable* results,
*except* if the operation is binary and both arguments are immutable.
So the product of two matrices or of a vector and a matrix is immutable
if and only if the two matrices or both the vector and the matrix are
immutable (see also~"Arithmetic for Lists").
It should be noted that `0 \* <obj>' is equivalent to `ZeroOp( <obj> )',
`-<obj>' is equivalent to `AdditiveInverseOp( <obj> )',
`<obj>^0' is equivalent to `OneOp( <obj> )', and
`<obj>^-1' is equivalent to `InverseOp( <obj> )'.
The operations `ZeroOp', `AdditiveInverseOp', `OneOp', and `InverseOp'
return *mutable* results whenever a mutable version of the result exists,
contrary to the attributes `Zero', `AdditiveInverse', `One', and `Inverse'.

(If one introduces new arithmetic objects then one need not install
methods for the attributes.
All methods installed for the non-attribute operations must obey
the rule about the mutability of the result.
This means that one may try to avoid the perhaps expensive creation
of a new object if both operands are immutable,
and of course no problems of this kind arise at all
in the usual case that the objects in question are not copyable.)
% This paragraph looks like a footnote, doesn't it?

In a few, relatively low-level algorithms, one wishes to treat a matrix
partly as a data structure, and manipulate and change its entries.
For this, the matrix needs to be mutable,
and the rule that attribute values are immutable is an obstacle.
For these situations, a  number of additional operations are provided,
for example `MutableTransposedMat' constructs a mutable matrix
(contrary to the attribute `TransposedMat'),
while `TriangulizeMat' modifies a mutable matrix in place
into upper triangular form.

Note that being immutable does not forbid an object to store knowledge.
For example, if it is found out that an immutable list is strictly
sorted then the list may store this information.
More precisely, an immutable object may change in any way,
provided that it continues to represent the same element.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Duplication of Objects}

\index{Copy}
\index{copy!an object}\index{clone!an object}
\Declaration{ShallowCopy}

\Declaration{StructuralCopy}
\beginexample
gap> obj:= [ [ 0, 1 ] ];;
gap> obj[2]:= obj[1];;
gap> obj[3]:= Immutable( obj[1] );;
gap> scp:= StructuralCopy( obj );;
gap> scp = obj; IsIdenticalObj( scp, obj );
true
false
gap> IsIdenticalObj( scp[1], obj[1] );
false
gap> IsIdenticalObj( scp[3], obj[3] );
true
gap> IsIdenticalObj( scp[1], scp[2] );
true
\endexample

That both `ShallowCopy' and `StructuralCopy' return the argument <obj>
itself if it is not copyable is consistent with this definition,
since there is no way to change <obj> by modifying the result of any of
the two functions,
because in fact there is no way to change this result at all.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
