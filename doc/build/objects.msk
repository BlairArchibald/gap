%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  objects.msk              GAP manual                     Thomas Breuer
%W                                                       Martin Schoenert
%%
%H  @(#)$Id$
%%

%T modify and use the text in `object.gd' for the discussion of
%T mutability and copyability
%T (in particular for `IsMutable' and `IsCopyable').

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Objects and Elements}

An *object* is anything in {\GAP} that can be assigned to a variable,
so nearly everything in {\GAP} is an object.

Different objects can be regarded as equal with respect to the equivalence
relation `{`='}',
in this case we say that the objects describe the same *element*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Objects}

Nearly all things one deals with in {\GAP} are *objects*.
For example, an integer is an object, as is a list of integers, a matrix,
a permutation, a function, a list of functions, a record, a group,
a coset or a conjugacy class in a group.

Examples of things that are not objects are
comments which are only lexical constructs,
`while' loops which are only syntactical constructs,
and expressions, such as `1 + 1';
but note that the value of an expression, in this case the integer `2',
is an object.

Objects can be assigned to variables,
and everything that can be assigned to a variable is an object.
Analogously, objects can be used as arguments of functions, and can be 
returned by functions.

\Declaration{IsObject}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements}

The equality operation ``{`='}'' defines an equivalence relation on all
{\GAP} objects.
The equivalence classes are called *elements*.

There are basically three reasons to regard different objects as
equal.  Firstly the same information may be stored in different
places.  Secondly the same information may be stored in different
ways; for example, a polynomial can be stored sparsely or densely.
Thirdly different information may be equal modulo a mathematical
equivalence relation.  For example, in a finitely presented group with
the relation $a^2 = 1$ the different objects $a$ and $a^3$ describe
the same element.

As an example of all three reasons, consider the possibility of storing
an integer in several places of the memory,
of representing it as a fraction with denominator 1,
or of representing it as a fraction with any denominator, and numerator
a suitable multiple of the denominator. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domains}

An especially important class of objects in {\GAP} are those whose
underlying mathematical abstraction is that of a  structured set, for
example a group, a conjugacy class, or a vector space.  Such objects
are called *domains*.  The equality relation between domains is always 
equality *as sets*, so that two domains are equal if and only if they
contain the same elements.

Domains play a central role in {\GAP}.  In a sense, the only reason
that {\GAP} supports objects such as integers and permutations is the
wish to form domains of them and compute the properties of those domains.

Domains are described in Chapter~"Domains and their Elements".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Identical Objects}

Two objects that are equal *as objects* (that is they actually refer
to the same area of computer memory) and not only w.r.t. the equality
relation `{`='}' are called *identical*.  Identical objects do of
course describe the same element.

\Declaration{IsIdenticalObj}

If two copies of a simple constant object (see section "Mutability and
Copyability") are created, it is not defined whether {\GAP} will
actually store two equal but non-identical objects, or just a single
object. For mutable objects, however, it is important to know whether
two value refer to identical or non-identical objects, and the
documentation of operations that return mutable values should make
clear whether the values returned are new, or may be identical to
values stored elsewhere.

\beginexample
gap> IsIdenticalObj( 10^6, 10^6);
true
gap> IsIdenticalObj( 10^12, 10^12);
false
gap> IsIdenticalObj( true, true);
true
\endexample

Generally, one may compute with objects but think of the results in
terms of the underlying elements because one is not interested in
locations in memory, data formats or information beyond underlying
equivalence relations. But there are cases where it is important to
distinguish the relations identity and equality.  This is best
illustrated with an example.  (The reader who is not familiar with
lists in {\GAP}, in particular element access and assignment, is
referred to Chapter~"Lists".)
\beginexample
gap> l1:= [ 1, 2, 3 ];; l2:= [ 1, 2, 3 ];;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
false
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 3 ]
gap> l1 = l2;
false
\endexample
The two lists `l1' and `l2' are equal but not identical.
Thus a change in `l1' does not affect `l2'.
\beginexample
gap> l1:= [ 1, 2, 3 ];; l2:= l1;;
gap> l1 = l2;
true
gap> IsIdenticalObj( l1, l2 );
true
gap> l1[3]:= 4;; l1; l2;
[ 1, 2, 4 ]
[ 1, 2, 4 ]
gap> l1 = l2;
true
\endexample
Here, `l1' and `l2' are identical objects,
so changing `l1' means a change to `l2' as well.

The library also provides:

\Declaration{IsNotIdenticalObj}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Mutability and Copyability}

Most objects with which one deals in {\GAP} are *immutable*. That is,
the element they represent will not change during the life of the
object. For instance, the permutation `(1,2)' will never become a
different permutation or a non-permutation (although a variable which
previously had `(1,2)' stored in it may subsequently have some other
value). Note that the actual object may change, for example to store
new information, or to adopt a more efficient representation.

For many purposes, however, *mutable* objects are useful.  These
objects may be changed to represent different elements during their
life. For example, mutable lists can be changed by assigning values to
positions or by unbinding values at certain positions.  Similarly, one
can assign values to components of a mutable record, or unbind them.

\Declaration{IsMutable}

In many situations, however, one wants to ensure that objects are
*immutable*, For example, take the identity of a matrix group.  Since
this matrix may be referred to as the identity of the group in several
places, it would be fatal to modify its entries, or add or unbind
rows. We can obtain an immutable copy of an object with:

\Declaration{Immutable}


\>MakeImmutable( <obj> ) F

One can turn the (mutable or immutable) object <obj> into an immutable
one with `MakeImmutable'; note that this also makes all subobjects of
<obj> immutable, so one should call `MakeImmutable' only if <obj> and
its mutable subobjects are newly created.  If one is not sure about
this, `Immutable' should be used.

Note that it is *not* possible to turn an immutable object into a
mutable one; only mutable copies can be made (see~"Duplication of
Objects").


Using `Immutable', it is possible to store an immutable identity
matrix or an immutable list of generators, and to pass around
references to this immutable object safely.  Only when a mutable
copy is really needed does the actual object have to be duplicated.
Compared to the situation without immutable objects, much unnecessary
copying is avoided this way.  Another advantage of immutability is
that lists of immutable objects may remember whether they are sorted
(see~"Sorted Lists and Sets"), which is not possible for lists of
mutable objects.

Objects for which only an immutable form exists in {\GAP} are called
*constants*.  Examples of constants are integers, permutations, and
domains.  Called with a constant as argument, `Immutable' and
`ShallowCopy' return this argument.

\Declaration{IsCopyable}


Note that, since a matrix is a list of lists, the behaviour of
`ShallowCopy' for a matrix must respect that for a list, so that given
an immutable matrix <mat>, `ShallowCopy' returns a mutable matrix
whose rows are identical to the rows of <mat>.  In particular the
rows are still immutable.  To get a matrix whose rows are mutable, one
can use `List( <mat>, ShallowCopy )'.

Since the operation `Immutable' must work for any object in {\GAP}, it 
follows that an immutable form of every object must be possible, even
if it is not sensible, and user-defined objects must allow for the
possibility of becoming immutable without notice. 

Another interesting example of mutable (and thus copyable) objects is
provided by *iterators*, see~"Iterators".  (Of course an immutable
form of an iterator is not very useful, but clearly `Immutable' will
yield such an object.)  Every call of `NextIterator' changes a mutable
iterator until it is exhausted, and this is the only way to change an
iterator.  `ShallowCopy' for an iterator <iter> is defined so as to return a
mutable iterator that has no mutable data in common with <iter>, and
that behaves equally to <iter> w.r.t.~`IsDoneIterator' and (if <iter>
is mutable) `NextIterator'.  Note that the meaning of the ``shallow
copy'' of an iterator that is returned by `ShallowCopy' is not as
obvious as for lists and records, and must be explicitly defined.

Many operations return immutable results, among those mainly
attributes (see~"Attributes"); examples of attributes are 'Size',
`Zero', `AdditiveInverse', `One', and `Inverse'.  Arithmetic
operations, such as the binary infix operations `+', `-', `*', `/',
`^', `mod', the unary `-', and operations such as `Comm' and
`LeftQuotient', return *mutable* results, *except* if the operation is
binary and both arguments are immutable.  So the product of two
matrices or of a vector and a matrix is immutable if and only if the
two matrices or both the vector and the matrix are immutable (see
also~"Arithmetic for Lists").  It should be noted that `0 \* <obj>' is
equivalent to `ZeroOp( <obj> )', `-<obj>' is equivalent to
`AdditiveInverseOp( <obj> )', `<obj>^0' is equivalent to `OneOp( <obj>
)', and `<obj>^-1' is equivalent to `InverseOp( <obj> )'.  The
operations `ZeroOp', `AdditiveInverseOp', `OneOp', and `InverseOp'
return *mutable* results whenever a mutable version of the result
exists, contrary to the attributes `Zero', `AdditiveInverse', `One',
and `Inverse'.

If one introduces new arithmetic objects then one need not install
methods for the attributes `One', `Zero', etc.. The methods for the
associated operations `OneOp' and `ZeroOp' will be called, and themn
the results made immutable. 

All methods installed for the arithmetic operations must obey the rule
about the mutability of the result.  This means that one may try to
avoid the perhaps expensive creation of a new object if both operands
are immutable, and of course no problems of this kind arise at all in
the usual case that the objects in question are not copyable.

In a few, relatively low-level algorithms, one wishes to treat a
matrix partly as a data structure, and manipulate and change its
entries.  For this, the matrix needs to be mutable, and the rule that
attribute values are immutable is an obstacle.  For these situations,
a number of additional operations are provided, for example
`MutableTransposedMat' constructs a mutable matrix (contrary to the
attribute `TransposedMat'), while `TriangulizeMat' modifies a mutable
matrix (in place) into upper triangular form.

Note that being immutable does not forbid an object to store
knowledge.  For example, if it is found out that an immutable list is
strictly sorted then the list may store this information.  More
precisely, an immutable object may change in any way, provided that it
continues to represent the same element.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Duplication of Objects}

\index{Copy}
\index{copy!an object}\index{clone!an object}
\Declaration{ShallowCopy}

\Declaration{StructuralCopy}
\beginexample
gap> obj:= [ [ 0, 1 ] ];;
gap> obj[2]:= obj[1];;
gap> obj[3]:= Immutable( obj[1] );;
gap> scp:= StructuralCopy( obj );;
gap> scp = obj; IsIdenticalObj( scp, obj );
true
false
gap> IsIdenticalObj( scp[1], obj[1] );
false
gap> IsIdenticalObj( scp[3], obj[3] );
true
gap> IsIdenticalObj( scp[1], scp[2] );
true
\endexample

That both `ShallowCopy' and `StructuralCopy' return the argument <obj>
itself if it is not copyable is consistent with this definition,
since there is no way to change <obj> by modifying the result of any of
the two functions,
because in fact there is no way to change this result at all.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Other Operations Applicable to any Object}

There are a number of general operations which can be applied, in
principle, to any object in {\GAP}. Some of these are documented
elsewhere -- see "String", "PrintObj" and
"Display". Others are mainly somewhat technical.

\Declaration{Name}

\beginexample
gap> g := Group((1,2,3),(1,2));
Group([ (1,2,3), (1,2) ])
gap> SetName(g, "S3");
gap> g;
S3
gap> Name(g);
"S3"
\endexample

\Declaration{IsInternallyConsistent}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
