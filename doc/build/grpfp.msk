%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  grpfp.msk                   GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Finitely Presented Groups}

A *finitely presented group* (in short: FpGroup) is a group generated by a
finite set of *abstract generators* subject to a finite set of *relations*
that these generators satisfy. Every finite group can be represented as a
finitely presented group.

Finitely presented groups are obtained by factoring a free group by a set
of relators. Their elements know about this presentation and compare
accordingly.

\beginexample
gap> f := FreeGroup( "a", "b" );;
gap> g := f / [ f.1^2, f.2^3, (f.1*f.2)^5 ];
<fp group on the generators [ a, b ]>
gap> GeneratorsOfGroup( g );
[ a, b ]
gap> a;
Variable: 'a' must have a value
\endexample

Note that you cannot call the generators by their names. These names are
not variables, but just display figures. So, if you want to access the
generators by their names, you first have to introduce the respective
variables and to assign the generators to them.

\beginexample
gap> a := g.1;; b := g.2;;
gap> GeneratorsOfGroup( g );
[ a, b ]
gap> a in f;
false
gap> a in g;
true
\endexample

Note that the generators of the free group are different from the
generators of the FpGroup (even though they are displayed by the same
names). That means that words in the generators of the free group are not
elements of the finitely presented group. Vice versa elements of the
FpGroup are not words.

\beginexample
gap> a*b = b*a;
false
gap> (b^2*a*b)^2 = a^0;
true
\endexample

Such calculations comparing elements of an FpGroup may run into problems:
There exist finitely
presented groups for which no algorithm exists (it is known that no such
algorithm can exist) that will tell for two arbitrary words in the
generators whether the corresponding elements in the FpGroup are equal.
Therefore the methods used by {\GAP} to compute in finitely
presented groups may run into warning errors, run out of memory or run
forever. If the FpGroup is (by theory) known to be finite the
algorithms are guaranteed to terminate (if there is sufficient memory
available), but the time needed for the calculation cannot be bounded a
priori. See "Coset Tables and Coset Enumeration".

\beginexample
gap> (b^2*a*b)^2;
b^2*a*b^3*a*b
gap> a^0;
<identity> of ...
\endexample

A consequence of our convention is that elements of finitely presented
groups are not printed in a unique way.

\Declaration{IsSubgroupFpGroup}
\Declaration{IsFpGroup}

Free groups are a special case of finitely presented groups, namely finitely
presented groups with no relators.

Another special case are groups given by polycyclic presentations. {\GAP}
uses a special representation for these groups which is created in a
different way. See chapter "Pc Groups" for details.

\Declaration{InfoFpGroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Finitely Presented Groups}

\>`<F>/<rels>'{for finitely presented groups}

creates a finitely presented group given by the presentation
$\langle<gens>\mid<rels>\rangle$ where <gens> are the generators of the free
group <F>.
Note that relations are entered as *relators*, i.e.,  as words in the
generators of  the free group.   To  enter an  equation  use the quotient
operator, i.e., for the  relation  $a^b   = ab$  one has to enter
`a^b/(a*b)'.

\beginexample
gap> f := FreeGroup( 3 );;
gap> f / [ f.1^4, f.2^3, f.3^5, f.1*f.2*f.3 ];
<fp group on the generators [ f1, f2, f3 ]>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparison of Elements of Finitely Presented Groups}

\>`<a> = <b>'{equality!elements of finitely presented groups}

Two elements of a finitely presented group are equal if they are equal in
this group. Nevertheless they may be represented as different words in the
generators. Because of the fundamental problems mentioned in the
introduction to this chapter such a test may take very long and cannot be
guaranteed to finish.


\>`<a> \< <b>'{smaller!elements of finitely presented groups}

Problems get even worse when trying to compute a total ordering on the
elements of a finitely presented group. As any ordering that is guaranteed
to be reproducable in different runs of {\GAP} or even with different groups
given by syntactically equal presentations would be prohibitively expensive
to implement, the ordering of elements is depending on a method chosen by
{\GAP} and not guaranteed to stay the same when repeating the construction
of an FpGroup. The only guarantee given for the `\<'
ordering for such elements is that it will stay the same for one family
during its lifetime. The attribute `FpElmComparisonMethod' is used to obtain
a comparison function for a family of FpGroup elements.

\Declaration{FpElmComparisonMethod}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Preimages in the Free Group}

\Declaration{FreeGroupOfFpGroup}
\Declaration{FreeGeneratorsOfFpGroup}
\Declaration{RelatorsOfFpGroup}
\beginexample
gap> f := FreeGroup( "a", "b" );;
gap> g := f / [ f.1^5, f.2^2, f.1^f.2*f.1 ];
<fp group on the generators [ a, b ]>
gap> Size( g );
10
gap> FreeGroupOfFpGroup( g ) = f;
true
gap> FreeGeneratorsOfFpGroup( g );
[ a, b ]
gap> RelatorsOfFpGroup( g );
[ a^5, b^2, b^-1*a*b*a ]
\endexample

Elements of a finitely presented group are not words, but are represented
using a word from the free group as representative. The following two
commands obtain this representative, respectively create an element in the
finitely presented group.

\Declaration{UnderlyingElement}
\beginexample
gap> w := g.1*g.2;
a*b
gap> IsWord( w );
false
gap> ue := UnderlyingElement( w );
a*b
gap> IsWord( ue );
true
\endexample

\Declaration{ElementOfFpGroup}
\beginexample
gap> ge := ElementOfFpGroup( FamilyObj( g.1 ), f.1*f.2 );
a*b
gap> ge in f;
false
gap> ge in g;
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Finitely Presented Groups}

Finitely presented groups are groups and so all operations for groups should
be applicable to them (though not necessarily efficient methods are
available.) Most methods for finitely presented groups rely on coset
enumeration. See "Coset Tables and Coset Enumeration" for details.

The command `IsomorphismPermGroup' can be used to obtain a faithful
permutation representation.
\beginexample
gap> f := FreeGroup( "a", "b" );
<free group on the generators [ a, b ]>
gap> g := f / [ f.1^2, f.2^3, (f.1*f.2)^5 ];
<fp group on the generators [ a, b ]>
gap> h := IsomorphismPermGroup( g );
[ a, b ] -> [ (1,2)(4,5), (2,3,4) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Coset Tables and Coset Enumeration}

Coset enumeration (see \cite{Neu82} for an explanation) is one of the
fundamental tools for the examination of finitely presented groups. This
section describes {\GAP} functions that can be used to invoke a coset
enumeration.

\Declaration{CosetTable}

The coset table is computed by a Todd-Coxeter coset enumeration. Note that
you may influence the performance of that enumeration by changing the values
of the global variables `CosetTableFpGroupDefaultLimit' and
`CosetTableFpGroupDefaultMaxLimit' described below.

\beginexample
gap> CosetTable( g, Subgroup( g, [ g.1, g.2*g.1*g.2*g.1*g.2^-1 ] ) );
[ [ 1, 3, 2, 5, 4 ], [ 1, 3, 2, 5, 4 ], [ 2, 4, 3, 1, 5 ], [ 4, 1, 3, 2, 5 ] ]
gap> List( last, PermList );
[ (2,3)(4,5), (2,3)(4,5), (1,2,4), (1,4,2) ]
\endexample

\Declaration{CosetTableInWholeGroup}

\index{OperationCosetsFpGroup}
\>FactorCosetOperation( <G>, <H> )!{for fp groups}

returns the action of <G> on the cosets of the subgroup <H> of <G>.

\beginexample
gap> u := Subgroup( g, [ g.1, g.1^g.2 ] );
Group([ a, b^-1*a*b ])
gap> FactorCosetOperation( g, u );
[ a, b ] -> [ (2,3)(5,6), (1,2,4)(3,5,6) ]
\endexample

\Declaration{SubgroupOfWholeGroupByCosetTable}

\Declaration{CosetTableFromGensAndRels}
\Declaration{CosetTableDefaultMaxLimit}

\begintt
gap> f := FreeGroup( "a", "b" );;
gap> u := Subgroup( f, [ f.2 ] );
Group([ b ])
gap> Index( f, u );
Error the coset enumeration has defined more than 64000 cosets:
type 'return;' if you want to continue with a new limit of 128000 cosets,
type 'quit;' if you want to quit the coset enumeration,
type 'maxlimit := 0; return;' in order to continue without a limit,
\endtt

At this point you can either continue the calculation with a larger
number of permitted cosets or stop the calculation if you don{\pif}t
expect the enumeration to finish (like in the example above).

Setting `CosetTableDefaultMaxLimit' to `infinity' (or to 0) will enforce all
coset enumerations to continue until they either get a result or exhaust the
whole available space.

\Declaration{CosetTableDefaultLimit}

\Declaration{AugmentedCosetTableMtc}
\Declaration{AugmentedCosetTableRrs}

\Declaration{MostFrequentGeneratorFpGroup}
\Declaration{IndicesInvolutaryGenerators}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Low Index Subgroups}

\Declaration{LowIndexSubgroupsFpGroup}

\beginexample
gap> LowIndexSubgroupsFpGroup( g, TrivialSubgroup( g ), 10 );
[ Group([ a, b ]), Group([ a, b*a*b^-1 ]), Group([ a, b*a*b*a^-1*b^-1 ]),
  Group([ a, b*a*b*a*b^-1*a^-1*b^-1 ]) ]
\endexample

As an example for an application of the optional parameter <excluded>, we
compute all conjugacy classes of torsion free subgroups of index at most
24 in the group $G = \langle x,y,z \mid x^2, y^4, z^3, (xy)^3, (yz)^2,
(xz)^3 \rangle$. It is know from theory that each torsion element of this
group is conjugate to a power of $x$, $y$, $z$, $xy$, $xz$, or $yz$.

\beginexample
gap> F := FreeGroup( "x", "y", "z" );;
gap> x := F.1;; y := F.2;; z := F.3;;
gap> G := F / [ x^2, y^4, z^3, (x*y)^3, (y*z)^2, (x*z)^3 ];;
gap> torsion := [ x, y, y^2, z, x*y, x*z, y*z ];;
gap> SetInfoLevel( InfoFpGroup, 2 );
gap> lis := LowIndexSubgroupsFpGroup( G, TrivialSubgroup( G ), 24, torsion );;
#I  LowIndexSubgroupsFpGroup called
#I   class 1 of index 24 and length 8
#I   class 2 of index 24 and length 24
#I   class 3 of index 24 and length 24
#I   class 4 of index 24 and length 24
#I   class 5 of index 24 and length 24
#I  LowIndexSubgroupsFpGroup returns 5 classes
gap> SetInfoLevel( InfoFpGroup, 0 );
gap> lis;
[ Group([ x*y*z^-1, z*x*z^-1*y^-1, x*z*x*y^-1*z^-1, y*x*z*y^-1*z^-1 ]),
  Group([ x*y*z^-1, z^2*x^-1*y^-1, x*z*y*x^-1*z^-1 ]),
  Group([ x*y*z^-1, x*z^2*x^-1*y^-1, y^2*x*y^-1*z^-1*x^-1 ]),
  Group([ x*y*z^-1, y^3*x^-1*z^-1*x^-1, y^2*z*x^-1*y^-1 ]),
  Group([ y*x*z^-1, x*y*z*y^-1*z^-1, y^2*z*x^-1*z^-1*x^-1 ]) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Abelian Invariants for Subgroups}

Using variations of coset enumeration it is possible to compute the abelian
invariants of a subgroup of a finitely presented group without computing a
complete presentation for the subgroup in the first place.

\Declaration{AbelianInvariantsSubgroupFpGroup}
\Declaration{AbelianInvariantsSubgroupFpGroupMtc}
\Declaration{AbelianInvariantsSubgroupFpGroupRrs}

\Declaration{AbelianInvariantsNormalClosureFpGroup}
\Declaration{AbelianInvariantsNormalClosureFpGroupRrs}
See "Subgroup Presentations" for details on the different strategies.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Converting Finite Groups to Finitely Presented Groups}

\Declaration{IsomorphismFpGroup}
\beginexample
gap> g := Group( (1,2,3,4), (1,2) );;
gap> iso := IsomorphismFpGroup( g );
[ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ] -> [ F1, F2, F3, F4 ]
gap> fp := Image( iso );
<fp group on the generators [ F1, F2, F3, F4 ]>
gap> RelatorsOfFpGroup( fp );
[ F1^2, F2^-1*F1^-1*F2*F1*F2^-1, F3^-1*F1^-1*F3*F1*F4^-1*F3^-1,
  F4^-1*F1^-1*F4*F1*F4^-1*F3^-1, F2^3, F3^-1*F2^-1*F3*F2*F4^-1*F3^-1,
  F4^-1*F2^-1*F4*F2*F3^-1, F3^2, F4^-1*F3^-1*F4*F3, F4^2 ]
\endexample

\Declaration{IsomorphismFpGroupByGenerators}
\beginexample
gap> iso := IsomorphismFpGroupByGenerators( g, [ (1,2,3,4), (1,2) ] );
[ (1,2,3,4), (1,2) ] -> [ F1, F2 ]
gap> fp := Image( iso );
<fp group on the generators [ F1, F2 ]>
gap> RelatorsOfFpGroup( fp );
[ F1*F2*F1*F2*F1*F2, F2^2, F1^-1*F2*F1^2*F2*F1*F2^2*F1*F2*F1^3*F2*F1*F2,
  F2^-1*F1^4*F2, F1^-2*F2*F1^2*F2*F1*F2*F1^3*F2*F1*F2,
  F2*F1*F2*F1^3*F2*F1*F2^2*F1*F2*F1^3*F2*F1*F2,
  F2^-1*F1^-1*F2*F1*F2*F1^3*F2*F1*F2*F1*F2*F1*F2^2*F1*F2*F1^3*F2*F1*F2,
  F2^-1*F1^-1*F2^-1*F1^-1*F2*F1*F2*F1^3*F2*F1*F2*F1*F2^2*F1*F2*F1^3*F2*F1*F2 ]
\endexample

If you are only interested in a finitely presented group isomorphic to <G>,
but not in the isomorphism, you may also use the functions
`PresentationViaCosetTable' and `FpGroupPresentation' (see "Creating
Presentations").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Quotient Methods}

This section still needs to be written.

