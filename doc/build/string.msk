%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  string.msk                  GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Strings and Characters}

\index{type!strings}
\index{doublequotes}
\index{singlequotes}

\Declaration{IsChar}
\beginexample
gap> x:= 'a';  IsChar( x );
'a'
true
gap> '*';
'*'
\endexample

\Declaration{IsString}
\beginexample
gap> s1 := ['H','e','l','l','o',' ','w','o','r','l','d','.'];
"Hello world."
gap> IsString( s1 );
true
gap> s2 := "Hello world.";
"Hello world."
gap> s1 = s2;
true
gap> s3 := "";
""           # the empty string
gap> s3 = [];
true
gap> IsString( [] );
true
gap> IsString( "123" );  IsString( 123 );
true
false
gap> IsString( [ '1', '2', '3' ] );
true
gap> IsString( [ '1', '2', , '4' ] );  IsString( [ '1', '2', 3 ] );
false        # strings must be dense
false        # strings must only contain characters
\endexample
\begintt
gap> s := "\007";
"\007"
gap> Print(s); # rings bell in many terminals
gap> 
\endtt

Note that a string is just a special case of a list.
So everything that is possible for lists (see~"Lists") is also possible
for strings.
Thus you can access the characters in such a string (see~"List Elements"),
test for membership (see~"Membership Test for Collections"),
ask for the length, concatenate strings (see~"Concatenation"),
form substrings etc.
You can even assign to a mutable string (see~"List Assignment").
Of course unless you assign a character in such a way that the list stays
dense,
the resulting list will no longer be a string.

\beginexample
gap> Length( s2 );
12
gap> s2[2];
'e'
gap> 'a' in s2;
false
gap> s2[2] := 'a';;  s2;
"Hallo world."
gap> s1{ [1..4] };
"Hell"
gap> Concatenation( s1{ [ 1 .. 6 ] }, s1{ [ 1 .. 4 ] } );
"Hello Hell"
\endexample

If a string is  displayed by `View', for example as  result of an evaluation
(see~"Main  Loop"), or  by `ViewObj'  and `PrintObj',  it is  displayed with
enclosing doublequotes. (But  note that there is an ambiguity  for the empty
string which is also  an empty list of arbitrary {\GAP}  objects; it is only
printed like  a string if  it was  input as empty  string or converted  to a
string  with "ConvertToStringRep".)  The  difference  between `ViewObj'  and
`PrintObj'  is that  the  latter prints  *all*  non-printable and  non-ASCII
characters  in  three  digit  octal  notation,  while  `ViewObj'  sends  all
printable characters to  the output stream. The output of  `PrintObj' can be
read back into {\GAP}.

Strings  behave  differently  from  other {\GAP}  objects  with  respect  to
`Print', `PrintTo',  or `AppendTo'. These  commands *interpret* a  string in
the sense that  they essentially send the characters of  the string directly
to the output stream/file. (But depending on  the type of the stream and the
presence of some special characters used  as hints for line breaks there may
be sent some additional newline (or backslash and newline) characters.

\begintt
gap> s4:= "abc\"def\nghi";;
gap> View( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> ViewObj( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> PrintObj( s4 );  Print( "\n" );
"abc\"def\nghi"
gap> Print( s4 );  Print( "\n" );
abc"def
ghi
gap> s := "German uses strange characters: \344\366\374\337\n";
"German uses strange characters: äöüß\n"
gap> PrintObj(s);
"German uses strange characters: \344\366\374\337\n"gap> 
gap> Print(s);
German uses strange characters: äöüß
\endtt

Note that only those line breaks are printed by `Print' that are contained
in the string (`\\n' characters, see~"Special Characters"),
as is shown in the example below.

\begintt
gap> s1;
"Hello world."
gap> Print( s1 );
Hello world.gap> Print( s1, "\nnext line\n" );
Hello world.
next line
gap> 
\endtt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Special Characters}

\index{escaped characters}
\index{special character sequences}

There are a number of *special character sequences* that can be used
between the singlequotes of a character literal or between the
doublequotes of a string literal to specify characters. 
They consist of two characters. The first is
a backslash $\backslash$. The second may be any character. If it is an octal
digit (from `0' to `7') there must be two more such digits. The meaning
is given in the following list

\beginlist

\indextt{\\n}\index{newline character}
\item{`\\n'}
    *newline character*.
    This is the character that, at least on UNIX systems,
    separates lines in a text file.
    Printing of this character in a string has the effect of moving
    the cursor down one line and back to the beginning of the line.

\indextt{\\\"}\index{doublequote character}
\item{`\\\"'}
    *doublequote character*.
    Inside a string a doublequote must be escaped by the backslash,
    because it is otherwise interpreted as end of the string.

\atindex{\\'}{@\noexpand`\\\pif'}\index{singlequote character}
\item{`\\\pif'}
    *singlequote character*.
    Inside a character a singlequote must escaped by the backslash,
    because it is otherwise interpreted as end of the character.

\indextt{\\\\}\index{backslash character}
\item{`\\\\'}
    *backslash character*.
    Inside a string a backslash must be escaped by another backslash,
    because it is otherwise interpreted as first character of
    an escape sequence.

\indextt{\\b}\index{backspace character}
\item{`\\b'}
    *backspace character*.
    Printing this character should have the effect of moving the cursor
    back one character.  Whether it works or not is system dependent
    and should not be relied upon.

\indextt{\\r}\index{carriage return character}
\item{`\\r'}
    *carriage return character*.
    Printing this character should have the effect of moving the cursor
    back to the beginning of the same line.  Whether this works or not
    is again system dependent.

\indextt{\\c}\index{flush character}
\item{`\\c'}
    *flush character*.
    This character is not printed.
    Its purpose is to flush the output queue.
    Usually {\GAP} waits until it sees a <newline> before it prints a string.
    If you want to display a string that does not include this character
    use `\\c'.

\indextt{\\XYZ}\index{octal character codes}
\item{`\\XYZ'}
    with X, Y, Z three octal digits. This is translated to the character
    correponding to the number X*64+Y*8+Z modulo 256. This can be used to 
    specify and store  arbitrary binary data as a string in  {\GAP}.

\index{escaping non-special characters}
\item{other}
    For any other character the backslash is simply ignored.

\endlist

Again, if the line is displayed as result of an evaluation, those escape
sequences are displayed in the same way that they are input. 

Only  `Print', `PrintTo', or `AppendTo' send the characters directly to the
output stream.

% XXX Should the characters \< and \> and their use with `Print' be documented?

\beginexample
gap> "This is one line.\nThis is another line.\n";
"This is one line.\nThis is another line.\n"
gap> Print( last );
This is one line.
This is another line.
\endexample

Note in particular that it is not  allowed to enclose a <newline> inside the
string. You can use the  special character sequence `$\backslash$n' to write
strings that include  <newline> characters. If, however, an  input string is
too  long to  fit on  a single  line it  is possible  to *continue*  it over
several lines.  In this case the  last character of each  input line, except
the last line  must be a backslash. Both backslash  and <newline> are thrown
away by  {\GAP} while reading  the string.  Note that the  same continuation
mechanism is available for identifiers and integers.

\beginexample
gap> "This is a very long string that does not fit on a line \
gap> and is therefore continued on the next line.";
"This is a very long string that does not fit on a line and is therefore conti\
nued on the next line."
\endexample

Note that the output is also continued, but at a different place
that is determined by the value of `SizeScreen' (see~"SizeScreen").


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Internally Represented Strings}

\index{convert!to a string}

\Declaration{IsStringRep}
\Declaration{ConvertToStringRep}
\Declaration{IsEmptyString}
\beginexample
gap> l:= [];;  IsString( l );  IsEmptyString( l );  IsEmpty( l );
true
false
true
gap> l;  ConvertToStringRep( l );  l;
[  ]
""
gap> IsEmptyString( l );  IsEmptyString( "" );  IsEmptyString( "abc" );
true
true
false
gap> ll:= [ 'a', 'b' ];  IsStringRep( ll );  ConvertToStringRep( ll );
"ab"
false
gap> ll;  IsStringRep( ll );
"ab"
true
\endexample

\Declaration{CharsFamily}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Recognizing Characters}

\Declaration{IsDigitChar}
\Declaration{IsLowerAlphaChar}
\Declaration{IsUpperAlphaChar}
\Declaration{IsAlphaChar}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparisons of Strings}

\>`<string1> = <string2>'{strings!equality of}
\>`<string1> \<> <string2>'{strings!inequality of}

The equality operator `=' returns to `true' if the two strings
<string1> and <string2> are equal and `false' otherwise. The inequality
operator `\<>' returns `true' if the two strings <string1> and <string2>
are not equal and `false' otherwise.

\beginexample
gap> "Hello world.\n" = "Hello world.\n";
true
gap> "Hello World.\n" = "Hello world.\n";
false # string comparison is case sensitive
gap> "Hello world." = "Hello world.\n";
false # the first string has no <newline>
gap> "Goodbye world.\n" = "Hello world.\n";
false
gap> [ 'a', 'b' ] = "ab";
true
\endexample

\>`<string1> \< <string2>'{strings!lexicographic ordering of}

The ordering of strings is lexicographically according to the order
implied by the underlying, system dependent, character set.

\beginexample
gap> "Hello world.\n" < "Hello world.\n";
false # the strings are equal
gap> "Hello World.\n" < "Hello world.\n";
true # in ASCII uppercase letters come before lowercase letters
gap> "Hello world." < "Hello world.\n";
true # prefixes are always smaller
gap> "Goodbye world.\n" < "Hello world.\n";
true # `G' comes before `H', in ASCII at least
\endexample

Strings can be compared via `\<' with certain {\GAP} objects that are not
strings, see~"Comparisons" for the details.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations to Produce or Manipulate Strings}

\Declaration{String}

\beginexample
gap> String(123);String([1,2,3]);
"123"
"[ 1, 2, 3 ]"
\endexample

\>HexStringInt( <int> ) F

returns a string which represents the integer <int> with hexa-decimal
digits (using `A-F' as digits `10-15'). The inverse translation can be achieved
with "IntHexString".

\Declaration{StringPP}
\beginexample
gap> StringPP(40320);
"2^7*3^2*5*7"
\endexample

\Declaration{WordAlp}
\beginexample
gap> List([0..5],i->WordAlp("abc",i));
[ "", "a", "b", "c", "aa", "ab" ]
\endexample

\Declaration{LowercaseString}
\beginexample
gap> LowercaseString("This Is UpperCase");
"this is uppercase"
\endexample

\Declaration{SplitString}
\beginexample
gap> SplitString( "substr1:substr2::substr4", ":" );
[ "substr1", "substr2", "", "substr4" ]
gap> SplitString( "a;b;c;d;", ";" );
[ "a", "b", "c", "d" ]
gap> SplitString( "/home//user//dir/", "", "/" );
[ "home", "user", "dir" ]
\endexample

\Declaration{ReplacedString}
\beginexample
gap> ReplacedString("abacab","a","zl");
"zlbzlczlb"
gap> ReplacedString("ababa", "aba","c");
"cba"
gap> ReplacedString("abacab","a","ba");
"babbacbab"
\endexample


\>NormalizeWhitespace( <string> ) F

This  function changes  the string  <string> in  place. The  characters `  '
(space), `\\n', `\\r' and `\\t' are considered as *white space*. Leading and
trailing white space characters in  <string> are removed. Sequences of white
space characters  between other  characters are replaced  by a  single space
character.

See "NormalizedWhitespace" for a non-destructive version.

\beginexample 
gap> s := "   x y \n\n\t\r  z\n   \n";
"   x y \n\n\t\r  z\n   \n"
gap> NormalizeWhitespace(s);
gap> s;
"x y z"
\endexample

\Declaration{NormalizedWhitespace}

For the possibility to print {\GAP} objects to strings, see~"String Streams".

\Declaration{JoinStringsWithSeparator}
\Declaration{Chomp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations to Evaluate Strings}

\index{evaluation!strings}
\>Int( <str> )!{for strings} A
\>Rat( <str> )!{for strings} A
\>IntHexString( <str> ) F

return either an integer (`Int' and `IntHexString'), or a rational (`Rat')
as represented by the string <str>.
`Int' returns `fail' if non-digit characters occur in <str>.
For `Rat', the argument string may start with the sign character `{'}-{'}',
followed by either a sequence of digits or by two sequences of digits
that are separated by one of the characters `{'}/{'}' or `{'}.{'}',
where the latter stands for a decimal dot.
(The methods only evaluate numbers but do *not* perform arithmetic!)

`IntHexString' evaluates an integer written with hexa-decimal digits. Here
the letters <a-f> or <A-F> are used as *digits* <10-15>. An error occurs
when a wrong character is found in the string. This function can be used
(together with "HexStringInt") for efficiently storing and reading large
integers from respectively into {\GAP}. Note that the translation between
integers and their hexa-decimal representation costs linear computation time
in terms of the number of digits, while translation from and into decimal
representation needs substantial computations.

\beginexample
gap> Int("12345")+1;
12346
gap> Int("123/45");
fail
gap> Int("1+2");
fail
gap> Int("-12");
-12
gap> Rat("123/45");
41/15
gap> Rat( "123.45" );
2469/20
gap> IntHexString("-abcdef0123456789");
-12379813738877118345
gap> HexStringInt(last);
"-ABCDEF0123456789"
\endexample

\Declaration{Ordinal}
\beginexample
gap> Ordinal(2);  Ordinal(21);  Ordinal(33);  Ordinal(-33);
"2nd"
"21st"
"33rd"
"-33rd"
\endexample

\Declaration{EvalString}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Calendar Arithmetic}

\FileHeader{string}[2]

\Declaration{DaysInYear}
\Declaration{DaysInMonth}
\beginexample
gap> DaysInYear(1998);
365
gap> DaysInMonth(3,1998);
31
\endexample

\Declaration{DMYDay}
\Declaration{DayDMY}
\Declaration{WeekDay}
\Declaration{StringDate}
\beginexample
gap> DayDMY([1,1,1970]);DayDMY([2,1,1970]);
0
1
gap> DMYDay(12345);
[ 20, 10, 2003 ]
gap> WeekDay([11,3,1998]);
"Wed"
gap> StringDate([11,3,1998]);
"11-Mar-1998"
\endexample

\Declaration{HMSMSec}
\Declaration{SecHMSM}
\Declaration{StringTime}
\beginexample
gap> HMSMSec(Factorial(10));
[ 1, 0, 28, 800 ]
gap> SecHMSM([1,10,5,13]);
4205013
gap> StringTime([1,10,5,13]);
" 1:10:05.013"
\endexample

\Declaration{SecondsDMYhms}
\Declaration{DMYhmsSeconds}
\beginexample
gap> SecondsDMYhms([ 9, 9, 2001, 1, 46, 40 ]);
1000000000
gap> DMYhmsSeconds(-1000000000);
[ 24, 4, 1938, 22, 13, 20 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

