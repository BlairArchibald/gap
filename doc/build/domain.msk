%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  domain.msk                   GAP documentation              Thomas Breuer
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Domains and their Elements}

\FileHeader{domain}[1]

The most important facts about domains are stated in Chapter~"tut:Domains"
of the {\GAP} Tutorial.

There are only few *operations* especially for domains
(see~"Operations for Domains"),
operations such as `Intersection' and `Random' are defined for the more
general situation of collections (see Chapter~"Collections").

%%  The fundamental suport for domains in {\GAP} was designed and implemented by
%%  Thomas Breuer.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operational Structure of Domains}

Domains have an *operational structure*,
that is, a collection of operations under which the domain is closed.
For example, a group is closed under multiplication,
taking the zeroth power of elements, and taking inverses of elements.
The operational structure may be empty,
examples of domains without additional structure are
the underlying relations of general mappings
(see~"Properties and Attributes of (General) Mappings").

The operations under which a domain is closed are a subset of
the operations that the elements of a domain admit.
It is possible that the elements admit more operations.
For example, matrices can be multiplied and added.
But addition plays no role in a group of matrices,
and multiplication plays no role in a vector space of matrices.
In particular, a matrix group is not closed under addition.

Note that the elements of a domain exist independently of this domain,
usually they existed already before the domain was created.
So it makes sense to say that a domain is *generated* by some elements
with respect to certain operations.

Of course, different sets of operations yield different notions of
generation.
For example, the group generated by some matrices is different from
the ring generated by these matrices, and these two will in general be
different from the vector space generated by the same matrices,
over a suitable field.

The other way round,
the same set of elements may be obtained by generation w.r.t.~different
notions of generation.
For example, one can get the group generated by two elements $g$ and $h$
also as the monoid generated by the elements $g$, $g^{-1}$, $h$, $h^{-1}$;
if both $g$ and $h$ have finite order then of course the group generated
by $g$ and $h$ coincides with the monoid generated by $g$ and $h$.

Additionally to the operational structure,
a domain can have properties.
For example, the multiplication of a group is associative,
and the multiplication in a field is commutative.

Note that associativity and commutativity depend on the set of
elements for which one considers the multiplication,
i.e., it depends on the domain.
For example, the multiplication in a full matrix ring over a field
is not commutative, whereas its restriction to the set of diagonal
matrices is commutative.

One important difference between the operational structure and the
properties of a domain is that the operational structure is fixed when
the domain is constructed, whereas properties can be discovered later.
For example, take a domain whose operational structure is given by
closure under multiplication.
If it is discovered that the inverses of all its elements
also do (by chance) lie in this domain,
being closed under taking inverses is *not* added to the operational
structure.
But a domain with operational structure of multiplication,
taking the identity, and taking inverses
will be treated as a group as soon as the multiplication is found out to
be associative for this domain.

The operational structures available in {\GAP} form a hierarchy,
which is explicitly formulated in terms of domain categories,
see~"Domain Categories".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Equality and Comparison of Domains}

\FileHeader{domain}[2]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Domains}

For several operational structures (see~"Operational Structure of Domains"),
{\GAP} provides functions to construct domains with this structure.
For example, `Group' returns groups, `VectorSpace' returns vector spaces etc.

\>`<Struct>( <arg1>, <arg2>, ... )'{Struct}@{\noexpand<Struct>} F

The syntax of these functions may vary, dependent on the structure in
question.
Usually a domain is constructed as the closure of some elements under the
given operations, that is, the domain is given by its *generators*.
For example, a group can be constructed from a list of generating
permutations or matrices or whatever is admissible as group elements,
and a vector space over a given field $F$ can be constructed from $F$ and
a list of appropriate vectors.

The idea of generation and generators in {\GAP} is that the domain
returned by a function such as `Group', `Algebra', or `FreeLeftModule'
*contains* the given generators.
This implies that the generators of a group must know how they are
multiplied and inverted,
the generators of a module must know how they are added and how scalar
multiplication works, and so on.
Thus one cannot use for example permutations as generators of a vector
space.

The function <Struct> first checks whether the arguments admit
the construction of a domain with the desired structure.
This is done by calling the operation

\>`IsGeneratorsOf<Struct>( [<info>, ]<gens>)'{IsGeneratorsOfStruct}%
@{`IsGeneratorsOf\noexpand<Struct>'} O

where <arglist> is the list of given generators and <info> an argument
of <Struct>, for example the field of scalars in the case that a
vector space shall be constructed.
If the check failed then <Struct> returns `fail',
otherwise it returns the result of `<Struct>ByGenerators' (see below).
(So if one wants to omit the check then one should call
`<Struct>ByGenerators' directly.)

\>`GeneratorsOf<Struct>( <D>)'{GeneratorsOfStruct}%
@{`GeneratorsOf\noexpand<Struct>'} A

For a domain <D> with operational structure corresponding to <Struct>,
the attribute `GeneratorsOf<Struct>' returns a list of corresponding
generators of <D>.
If these generators were not yet stored in <D> then <D> must know *some*
generators if `GeneratorsOf<Struct>' shall have a chance to compute the
desired result;
for example, monoid generators of a group can be computed from known
group generators (and vice versa).
Note that several notions of generation may be meaningful for a given
domain, so it makes no sense to ask for ``the generators of a domain''.
Further note that the generators may depend on other information about <D>.
For example the generators of a vector space depend on the underlying field
of scalars; the vector space generators of a vector space over the field
with four elements need not generate the same vector space when this is
viewed as a space over the field with two elements.

\>`<Struct>ByGenerators( [<info>, ]<gens> )'{StructByGenerators}%
@{`\noexpand<Struct>ByGenerators'} O

Domain construction from generators <gens> is implemented by operations
`<Struct>ByGenerators',
which are called by the simple functions <Struct>;
methods can be installed only for the operations.
Note that additional information <info> may be necessary
to construct the domain;
for example, a vector space needs the underlying field of scalars
in addition to the list of vector space generators.
The `GeneratorsOf<Struct>' value of the returned domain need *not*
be equal to <gens>.
But if a domain <D> is printed as `<Struct>([<a>, <b>, ...])' and if
there is an attribute `GeneratorsOf<Struct>' then the list
`GeneratorsOf<Struct>( <D> )' is guaranteed to be equal to
`[ <a>, <b>, ... ]'.

\>`<Struct>WithGenerators( [<info>, ]<gens> )'{StructWithGenerators}%
@{`\noexpand<Struct>WithGenerators'} O

The only difference between `<Struct>ByGenerators' and
`<Struct>WithGenerators' is that the latter guarantees that the
`GeneratorsOf<Struct>' value of the result is equal to the given
generators <gens>.

\>`Closure<Struct>( <D>, <obj> )'{ClosureStruct}@{`Closure\noexpand<Struct>'} O

For constructing a domain as the closure of a given domain with an
element or another domain, one can use the operation `Closure<Struct>'.
It returns the smallest domain with operational structure corresponding to
<Struct> that contains <D> as a subset and <obj> as an element.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Changing the Structure}

The same set of elements can have different operational structures.
For example, it may happen that a monoid $M$ does in fact contain
the inverses of all of its elements;
if $M$ has not been constructed as a group (see~"Domain Categories")
then it is reasonable to ask for the group that is equal to $M$.

\>`As<Struct>( [<info>, ]<D> )'{AsStruct}@{`As\noexpand<Struct>'} O

If <D> is a domain that is closed under the operational structure
given by <Struct> then `As<Struct>' returns a domain <E> that consists
of the same elements (that is, `<D> = <E>') and that has this
operational structure (that is, `Is<Struct>( <E> )' is `true');
if <D> is not closed under the structure given by <Struct> then
`As<Struct>' returns `fail'.

If additional information besides generators are necessary to define <D>
then the argument <info> describes the value of this information for the
desired domain.
For example, if we want to view <D> as a vector space over the field
with two elements then we may call `AsVectorSpace( GF(2), <D> )';
this allows us to change the underlying field of scalars,
for example if <D> is a vector space over the field with four elements.
Again, if <D> is not equal to a domain with the desired structure and
additional information then `fail' is returned.

In the case that no additional information <info> is related to the
structure given by <Struct>,
the operation `As<Struct>' is in fact an attribute (see~"Attributes").

See the index of the {\GAP} Reference Manual for an overview of the available
`As<Struct>' functions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Changing the Representation}

Often it is useful to answer questions about a domain via computations in
a different but isomorphic domain.
In the sense that this approach keeps the structure and changes the
underlying set of elements, it can be viewed as a counterpart of keeping the
set of elements and changing its structure (see~"Changing the Structure").

One reason for doing so can be that computations with the elements in the
given domain are not very efficient.
For example, if one is given a solvable matrix group
(see Chapter~"Matrix Groups") then one can compute an isomorphism to a
polycyclicly presented group $G$, say (see Chapter~"Polycyclic Groups");
the multiplication of two matrices --which is essentially determined by
the dimension of the matrices-- is much more expensive than the
multiplication of two elements in $G$ --which is essentially determined by
the composition length of $G$.

\>`Isomorphism<Rep><Struct>( <D> )'{IsomorphismRepStruct}%
@{`Isomorphism\noexpand<Rep>\noexpand<Struct>'} A

If <D> is a domain that is closed under the operational structure
given by <Struct> then `Isomorphism<Rep><Struct>' returns a mapping <hom>
from <D> to a domain $E$ having structure given by <Struct>,
such that <hom> respects the structure <Struct>
and <Rep> describes the representation of the elements in $E$.
If no domain $E$ with the required properties exists then `fail' is
returned.

For example, `IsomorphismPermGroup' (see~"IsomorphismPermGroup") takes a
group as its argument and returns a group homomorphism
(see~"Group Homomorphisms") onto an isomorphic permutation group
(see Chapter~"Permutation Groups") provided the original
group is finite; for infinite groups, `IsomorphismPermGroup' returns `fail'.
Similarly, `IsomorphismPcGroup' (see~"IsomorphismPcGroup") returns a group
homomorphism from its argument to a polycyclicly presented group
(see~"Pc Groups") if the argument is polycyclic, and `fail' otherwise.

See the index of the {\GAP} Reference Manual for an overview of the available
`Isomorphism<Rep><Struct>' functions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Domain Categories}

As mentioned in~"Operational Structure of Domains",
the operational structure of a domain is fixed when the domain is
constructed.
For example, if <D> was constructed by `Monoid' then <D> is in general not
regarded as a group in {\GAP},
even if <D> is in fact closed under taking inverses.
In this case, `IsGroup' returns `false' for <D>.
The operational structure determines which operations are applicable for
a domain, so for example `SylowSubgroup' is not defined for <D>
and therefore will signal an error.

\>`Is<Struct>( <D> )'{IsStruct}@{`Is\noexpand<Struct>'}

The functions `Is<Struct>' implement the tests whether a domain <D> has the
respective operational structure (upon construction).
`Is<Struct>' is a filter (see~"Types of Objects") that involves certain
categories (see~"Categories")
and usually also certain properties (see~"Properties").
For example, `IsGroup' is equivalent to
`IsMagmaWithInverses and IsAssociative',
the first being a category and the second being a property.

Implications between domain categories describe the hierarchy of
operational structures available in {\GAP}.
Here are some typical examples.

\beginlist%unordered
\item{--}
    `IsDomain' is implied by each domain category,
\item{--}
    `IsMagma' is implied by each category that describes the closure under
    multiplication `\*',
\item{--}
    `IsAdditiveMagma' is implied by each category that describes the closure
    under addition `+',
\item{--}
    `IsMagmaWithOne' implies `IsMagma';
    a *magma-with-one* is a magma such that each element
    (and thus also the magma itself) can be asked for its zeroth power,
\item{--}
    `IsMagmaWithInverses' implies `IsMagmaWithOne';
    a *magma-with-inverses* is a magma such that each element
    can be asked for its inverse;
    important special cases are *groups*,
    which in addition are associative,
\item{--}
    a *ring* is a magma that is also an additive group,
\item{--}
    a *ring-with-one* is a ring that is also a magma-with-one,
\item{--}
    a *division ring* is a ring-with-one that is also closed under taking
    inverses of nonzero elements,
\item{--}
    a *field* is a commutative division ring.
\endlist

Each operational structure <Struct> has associated with it 
a domain category `Is<Struct>',
and operations `<Struct>ByGenerators' for constructing a domain from
generators,
`GeneratorsOf<Struct>' for storing and accessing generators w.r.t.~this
structure,
`Closure<Struct>' for forming the closure,
and `As<Struct>' for getting a domain with the desired structure from one
with weaker operational structure and for testing whether a given domain
can be regarded as a domain with <Struct>.

The functions applicable to domains with the various structures
are described in the corresponding chapters of the Reference Manual.
For example, functions for rings, fields, groups, and vector spaces
are described in Chapters~"Rings", "Fields and Division Rings",
"Groups", and "Vector Spaces", respectively.
More general functions for arbitrary collections can be found in
Chapter~"Collections".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Parents}

\Declaration{Parent}
\beginexample
gap> g:= Group( (1,2,3), (1,2) );; h:= Group( (1,2) );;
gap> HasParent( g );  HasParent( h );
false
false
gap> SetParent( h, g );
gap> Parent( g );  Parent( h );
Group([ (1,2,3), (1,2) ])
Group([ (1,2,3), (1,2) ])
gap> HasParent( g );  HasParent( h );
false
true
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Subdomains}

\index{Subdomains}

For many domains <D>, there are functions that construct certain subsets <S>
of <D> as domains with parent (see~"Parents") already set to <D>.
For example, if <G> is a group that contains the elements in the list <gens>
then `Subgroup( <G>, <gens> )' returns a group <S> that is generated by the
elements in <gens> and with `Parent( <S> ) = <G>'.

\>`Sub<struct>( <D>, <gens> )'{Substruct}@{`Sub\noexpand<struct>'} F

More general, if <D> is a domain whose algebraic structure is given by the
function <Struct> (for example `Group', `Algebra', `Field')
then the function `Sub<struct>' (for example `Subgroup', `Subalgebra',
`Subfield') returns domains with structure <Struct> and parent set to
the first argument.

\>`Sub<struct>NC( <D>, <gens> )'{SubstructNC}@{`Sub\noexpand<struct>NC'} F

Each function `Sub<struct>' checks that the <Struct> generated by
<gens> is in fact a subset of <D>.
If one wants to omit this check then one can call `Sub<struct>NC' instead;
the suffix `NC' stands for ``no  check''.

\>`AsSub<struct>( <D>, <S> )'{AsSubstruct}@{`AsSub\noexpand<struct>'} F

first constructs `As<struct>( [<info>, ]<S> )',
where <info> depends on <D> and <S>,
and then sets the parent (see~"Parents") of this new domain to <D>.

\>`IsSub<struct>( <D>, <S> )'{IsSubstruct}@{`IsSub\noexpand<struct>'} F

There is no real need for functions that check whether a domain <S> is a
`Sub<struct>' of a domain <D>,
since this is equivalent to the checks whether <S> is a <Struct> and <S>
is a subset of <D>.
Note that in many cases, only the subset relation is what one really wants
to check, and that appropriate methods for the operation `IsSubset'
(see~"IsSubset") are available for many special situations,
such as the test whether a group is contained in another group,
where only generators need to be checked.

If a function `IsSub<struct>' is available in {\GAP} then it is implemented
as first a call to `Is<Struct>' for the second argument and then a call to
`IsSubset' for the two arguments.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Domains}

For the meaning of the attributes `Characteristic', `One', `Zero'
in the case of a domain argument,
see~"Attributes and Properties of Elements".


\Declaration{IsGeneralizedDomain}
\Declaration{GeneratorsOfDomain}

\Declaration{Domain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and Properties of Elements}

The following attributes and properties for elements and domains
correspond to the operational structure.

\Declaration{Characteristic}

\Declaration{OneImmutable}
\Declaration{ZeroImmutable}
\Declaration{MultiplicativeZeroOp}

\Declaration{IsOne}
\Declaration{IsZero}
\Declaration{IsIdempotent}

\Declaration{InverseImmutable}
\Declaration{AdditiveInverseImmutable}

\Declaration{Order}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparison Operations for Elements}

Binary comparison operations have been introduced already in "Comparisons".
The underlying operations for which methods can be installed are the
following.

\>`\\=( <left-expr>, <right-expr> )'{equality!operation} O
\>`\\\<( <left-expr>, <right-expr> )'{comparison!operation} O

Note that the comparisons via `\<>', `\<=', `>', and `>=' are delegated to
the operations `\\=' and `\\\<'.

In general, objects in *different* families cannot be compared with `\<'.
For the reason and for exceptions from this rule, see~"Comparisons".

For some objects a ``normal form'' is hard to compute and thus equality of
elements of a domain might be expensive to test. Therefore {\GAP}
provides a (slightly technical) property with which an algorithm can test
whether an efficient equality test is available for elements of a certain
kind.

\Declaration{CanEasilyCompareElements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Arithmetic Operations for Elements}

*Binary* arithmetic operations have been introduced already in
"Arithmetic Operators".
The underlying operations for which methods can be installed are the
following.

\>`\\+( <left-expr>, <right-expr> )'{addition!operation} O
\>`\\\*( <left-expr>, <right-expr> )'{multiplication!operation} O
\>`\\/( <left-expr>, <right-expr> )'{division!operation} O
\>`\\^( <left-expr>, <right-expr> )'{exponentiation!operation} O
\>`\\mod( <left-expr>, <right-expr> )'{remainder!operation} O

For details about special methods for `\\mod', consult the index entries
for ``mod''.

% (no Declaration available for them?)

\Declaration{LeftQuotient}
\Declaration{Comm}
\beginexample
gap> a:= (1,3)(4,6);; b:= (1,6,5,4,3,2);;
gap> Comm( a, b );
(1,5,3)(2,6,4)
gap> LeftQuotient( a, b );
(1,2)(3,6)(4,5)
\endexample

\Declaration{LieBracket}

The addition `\\+' is assumed to be associative but *not* assumed to be
commutative (see~"IsAdditivelyCommutative").
The multiplication `\\\*' is *not* assumed to be commutative or associative
(see~"IsCommutative", "IsAssociative").

\Declaration{Sqrt}


% missing facts about the others ...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Relations Between Domains}

Domains are often constructed relative to other domains.
The probably most usual case is to form a *subset* of a domain,
for example the intersection (see~"Intersection") of two domains,
or a Sylow subgroup of a given group (see~"SylowSubgroup").

In such a situation, the new domain can gain knowledge by exploiting that
several attributes are maintained under taking subsets.
For example, the intersection of an arbitrary domain with a finite domain
is clearly finite, a Sylow subgroup of an abelian group is abelian, too,
and so on.

Since usually the new domain has access to the knowledge of the old domain(s)
only when it is created (see~"Constructing Subdomains" for the exception),
this is the right moment to take advantage of the subset relation.

Analogous relations occur when a *factor structure* is created from a domain
and a subset, and when a domain *isomorphic* to a given one is created.

\Declaration{UseSubsetRelation}
\beginexample
gap> g:= Group( (1,2), (3,4), (5,6) );; h:= Group( (1,2), (3,4) );;
gap> IsAbelian( g );  HasIsAbelian( h );
true
false
gap> UseSubsetRelation( g, h );;  HasIsAbelian( h );  IsAbelian( h );
true
true
\endexample

\Declaration{UseIsomorphismRelation}
\beginexample
gap> g:= Group( (1,2) );;  h:= Group( [ [ -1 ] ] );;
gap> Size( g );  HasSize( h );
2
false
gap> UseIsomorphismRelation( g, h );;  HasSize( h );  Size( h );
true
2
\endexample

\Declaration{UseFactorRelation}
\beginexample
gap> g:= Group( (1,2,3,4), (1,2) );; h:= Group( (1,2,3), (1,2) );;
gap> IsSolvableGroup( g );  HasIsSolvableGroup( h );
true
false
gap> UseFactorRelation( g, Subgroup( g, [ (1,2)(3,4), (1,3)(2,4) ] ), h );;
gap> HasIsSolvableGroup( h );  IsSolvableGroup( h );
true
true
\endexample

The following functions are used to tell {\GAP} under what conditions
an attribute is maintained under taking subsets,
or forming factor structures or isomorphic domains.
This is used only when a new attribute is created,
see~"prg:Creating Attributes and Properties" in ``Programming in {\GAP}''.
For the attributes already available, such as `IsFinite' and `IsCommutative',
the maintenances are already notified.

\Declaration{InstallSubsetMaintenance}
\Declaration{InstallIsomorphismMaintenance}
\Declaration{InstallFactorMaintenance}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Useful Categories of Elements}

This section and the following one are rather technical,
and may be interesting only for those {\GAP} users who want to implement
new kinds of elements.

It deals with certain categories of elements that are useful mainly for the
design of elements, from the viewpoint that one wants to form certain domains
of these elements.
For example, a domain closed under multiplication `\*' (a so-called magma,
see Chapter~"Magmas") makes sense only if its elements can be multiplied,
and the latter is indicated by the category `IsMultiplicativeElement'
for each element.
Again note that the underlying idea is that a domain is regarded as
*generated* by given elements, and that these elements carry information
about the desired domain.
For general information on categories and their hierarchies,
see~"Categories".

\Declaration{IsExtAElement}
\Declaration{IsNearAdditiveElement}
\Declaration{IsAdditiveElement}
\Declaration{IsNearAdditiveElementWithZero}
\Declaration{IsAdditiveElementWithZero}
\Declaration{IsNearAdditiveElementWithInverse}
\Declaration{IsAdditiveElementWithInverse}
\Declaration{IsExtLElement}
\Declaration{IsExtRElement}
\Declaration{IsMultiplicativeElement}
\Declaration{IsMultiplicativeElementWithOne}
\Declaration{IsMultiplicativeElementWithZero}
\Declaration{IsMultiplicativeElementWithInverse}
\Declaration{IsVector}
\Declaration{IsNearRingElement}
\Declaration{IsRingElement}
\Declaration{IsNearRingElementWithOne}
\Declaration{IsRingElementWithOne}
\Declaration{IsNearRingElementWithInverse}
\Declaration{IsRingElementWithInverse}

More special categories of this kind are described in the contexts where
they arise,
they are `IsRowVector' (see~"IsRowVector"),
`IsMatrix' (see~"IsMatrix"),
`IsOrdinaryMatrix' (see~"IsOrdinaryMatrix"),
and `IsLieMatrix' (see~"IsLieMatrix").


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Useful Categories for all Elements of a Family}

The following categories of elements are to be understood mainly as
categories for all objects in a family,
they are usually used as third argument of `NewFamily'
(see~"prg:Creating Families" in ``Programming in {\GAP}'').
The purpose of each of the following categories is then to guarantee that
each collection of its elements automatically lies in its collections
category (see~"CategoryCollections").

For example, the multiplication of permutations is associative,
and it is stored in the family of permutations that each permutation lies
in `IsAssociativeElement'.
As a consequence, each magma consisting of permutations
(more precisely: each collection that lies in the family
`CollectionsFamily( PermutationsFamily )', see~"CollectionsFamily")
automatically lies in `CategoryCollections( IsAssociativeElement )'.
A magma in this category is always known to be associative, via a logical
implication (see~"prg:Logical Implications" in ``Programming in {\GAP}'').

Similarly, if a family knows that all its elements are in the categories
`IsJacobianElement' and `IsZeroSquaredElement',
then each algebra of these elements is automatically known to be a
Lie algebra (see~"Algebras").

\Declaration{IsAssociativeElement}
\Declaration{IsAdditivelyCommutativeElement}
\Declaration{IsCommutativeElement}
\Declaration{IsFiniteOrderElement}
\Declaration{IsJacobianElement}
\Declaration{IsZeroSquaredElement}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

