%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  groups.msk                  GAP documentation            Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St  Andrews, Scotland
%%
\PreliminaryChapter{Groups}

This chapter explains how to create groups and defines operations for groups
whose definition does not depend on the representation. (However methods for
these operations in most cases will make use of the representation.)

If not otherwise specified in all examples in this chapter, the group `g'
will be the symmetric group $S_4$ acting on the letters $\{1,\ldots,4\}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group elements}

Groups in {\GAP} are written multiplicatively. The elements from which a
group can be generated must permit multiplication and multiplicative
inversion.
\Declaration{IsMultiplicativeElementWithOne}

\beginexample
gap> a:=(1,2,3);;b:=(2,3,4);;
gap> One(a);
()
gap> Inverse(b);
(2,4,3)
gap> a*b;   
(1,3)(2,4)
\endexample

\Declaration{IsFiniteOrderElement}
\Declaration{Order}

\beginexample
gap> a:=(1,2,3);;b:=(2,3,4);;
gap> Order(a*b);
2
\endexample
\begintt
gap> Order([[1,1],[0,1]]);
#I  Order: warning, order of <mat> might be infinite
\endtt
This last example will run into an infinite loop.

\index{order! of a group}
To compute the order of a group, use the command `Size'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creating Groups}

\Declaration{Group}
\Declaration{GroupWithGenerators}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));
Group( [ (1,2,3,4), (1,2) ] )
\endexample

\Declaration{IsGroup}
\beginexample
gap> IsGroup(g);
true
\endexample

\Declaration{GeneratorsOfGroup}
\beginexample
gap> GeneratorsOfGroup(g);
[ (1,2,3,4), (1,2) ]
\endexample

\Declaration{AsGroup}
\beginexample
gap> AsGroup([(1,2)]);           
fail
gap> AsGroup([(),(1,2)]);
Group( [ (1,2) ] )
\endexample

\Declaration{ClosureGroup}
\beginexample
gap> ClosureGroup(g,(1,5));
Group( [ (1,2,3,4), (1,2), (1,5) ] )
gap> ClosureGroup(g,[(1,5),(1,7)]);
Group([ (1,2,3,4), (1,2), (1,5), (1,7) ])
gap> ClosureGroup(g,Group((5,6,7)));
Group([ (1,2,3,4), (1,2), (5,6,7) ])
\endexample

\Declaration{ClosureGroupDefault}

\Declaration{ConjugateGroup}
\beginexample
gap> ConjugateGroup(g,(1,5));
Group( [ (2,3,4,5), (2,5) ] )
\endexample

\Declaration{InfoGroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups}

For the general concept of parents and subdomains,
see~"Parents" and~"Subdomains".

\Declaration{Subgroup}
\beginexample
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);
Group( [ (1,2,3), (1,2) ] )
\endexample

\Declaration{Index}
\beginexample
gap> Index(g,u);
4
\endexample


\Declaration{IndexInWholeGroup}

\Declaration{AsSubgroup}
\beginexample
gap> v:=AsSubgroup(g,Group((1,2,3),(1,4)));
Group( [ (1,2,3), (1,4) ] )
gap> Parent(v);
Group( [ (1,2,3,4), (1,2) ] )
\endexample

\Declaration{IsSubgroup}
\beginexample
gap> IsSubgroup(g,u);
true
gap> v:=Group((1,2,3),(1,2));    
Group( [ (1,2,3), (1,2) ] )
gap> u=v; 
true
gap> IsSubgroup(g,v);
true
\endexample

\Declaration{IsNormal}
\beginexample
gap> IsNormal(g,u);
false
\endexample

\Declaration{ConjugateSubgroup}
\Declaration{ConjugateSubgroups}

\Declaration{IsSubnormal}
\beginexample
gap> IsSubnormal(g,Group((1,2,3)));   
false
gap> IsSubnormal(g,Group((1,2)(3,4)));
true
\endexample

\FileHeader{grp}[2]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Cosets}

\index{right cosets}

\index{coset}
\Declaration{RightCoset}
\beginexample
gap> c:=RightCoset(u,(2,3,4));
RightCoset(Group( [ (1,2,3), (1,2) ] ),(2,3,4))
gap> ActingDomain(c);
Group( [ (1,2,3), (1,2) ] )
gap> Representative(c);
(2,3,4)
gap> Size(c);
6
gap> AsList(c);
[ (2,3,4), (1,4,2), (1,3)(2,4), (2,4), (1,4,2,3), (1,3,4,2) ]
\endexample

\Declaration{RightCosets}
\beginexample
gap> RightCosets(g,u);
[ RightCoset(Group( [ (1,2,3), (1,2) ] ),()), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,2)(3,4)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,3)(2,4)), 
  RightCoset(Group( [ (1,2,3), (1,2) ] ),(1,4)(2,3)) ]
\endexample

\Declaration{CanonicalRightCosetElement}
\beginexample
gap> CanonicalRightCosetElement(u,(2,4,3));
(3,4)
\endexample

\Declaration{IsRightCoset}

\index{left cosets}
{\GAP} does not provide left cosets as a separate data type, but as the left
coset $gU$ consists of exactly the inverses of the elements of the right
coset $ug^{-1}$ calculations with left cosets can be emulated using right
cosets by inverting the representatives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Transversals}

\Declaration{RightTransversal}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;u:=Subgroup(g,[(1,2,3),(1,2)]);;
gap> rt:=RightTransversal(g,u);
RightTransversal(Group([(1,2,3,4),(1,2)]),Group([(1,2,3),(1,2)]))
gap> Length(rt);
4
gap> Position(rt,(1,2,3));
fail
gap> PositionCanonical(rt,(1,2,3));
1
gap> rt[1];
()
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Double Cosets}

\Declaration{DoubleCoset}
\Declaration{RepresentativesContainedRightCosets}
\beginexample
gap> u:=Subgroup(g,[(1,2,3),(1,2)]);;v:=Subgroup(g,[(3,4)]);;
gap> c:=DoubleCoset(u,(2,4),v);             
DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(2,4),Group( [ (3,4) ] ))
gap> (1,2,3) in c;
false
gap> (2,3,4) in c;
true
gap> LeftActingGroup(c);
Group( [ (1,2,3), (1,2) ] )
gap> RightActingGroup(c);
Group( [ (3,4) ] )
gap> RepresentativesContainedRightCosets(c);
[ (2,3,4) ]
\endexample

\Declaration{DoubleCosets}
\beginexample
gap> dc:=DoubleCosets(g,u,v);
[ DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(),Group( [ (3,4) ] )), 
  DoubleCoset(Group( [ (1,2,3), (1,2) ] ),(2,3,4),Group( 
    [ (3,4) ] )), DoubleCoset(Group( [ (1,2,3), (1,2) ] ),
    (1,2,3,4),Group( [ (3,4) ] )) ]
gap> List(dc,Representative);
[ (), (2,3,4), (1,2,3,4) ]
\endexample

\Declaration{IsDoubleCoset}

\Declaration{InfoCoset}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Specific and Parametrized Subgroups}

\Declaration{TrivialSubgroup}
\beginexample
gap> TrivialSubgroup(g);
Group( () )
\endexample

\Declaration{CommutatorSubgroup}
\Declaration{DerivedSubgroup}
\beginexample
gap> DerivedSubgroup(g);
Group( [ (1,3,2), (2,4,3) ] )
gap> CommutatorSubgroup(g,last); 
Group( [ (1,3,4), (1,2,4), (1,2,3), (1,2,4) ] )
\endexample

\Declaration{FittingSubgroup}
\beginexample
gap> FittingSubgroup(g);
Group( [ (1,2)(3,4), (1,3)(2,4) ] )
\endexample

\Declaration{FrattiniSubgroup}
\beginexample
gap> FrattiniSubgroup(g);
Group( () )
\endexample

\Declaration{PrefrattiniSubgroup}
\beginexample
gap> G := SmallGroup( 60, 7 );
<pc group with 4 generators>
gap> P := PrefrattiniSubgroup(G);
Group([ f2 ])
gap> IsNilpotent(P);
true
gap> Core(G,P);
Group([])
gap> FrattiniSubgroup(G);
Group([])
\endexample

\Declaration{PerfectResiduum}
\beginexample
gap> PerfectResiduum(Group((1,2,3,4,5),(1,2)));
Group([ (1,3,2), (1,4,3), (3,5,4) ])
\endexample

\Declaration{RadicalGroup}
\beginexample
gap> RadicalGroup(SL(2,5));
Group([ [ [ Z(5)^2, 0*Z(5) ], [ 0*Z(5), Z(5)^2 ] ] ])
\endexample

\Declaration{Socle}
\beginexample
gap> Socle(g);
Group([ (1,4)(2,3), (1,2)(3,4) ])
\endexample

\Declaration{SupersolvableResiduum}
\beginexample
gap> SupersolvableResiduum(g);
Group( [ (), (1,2)(3,4), (1,4)(2,3) ] )
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sylow Subgroups and Hall Subgroups}

\Declaration{SylowSubgroup}
\beginexample
gap> SylowSubgroup(g,2);
Group( [ (2,3), (1,4), (1,2)(3,4) ] )
\endexample

\Declaration{SylowComplement}
\beginexample
gap> SylowComplement(g,3);
Group([ (3,4), (1,4)(2,3), (1,2)(3,4) ])
\endexample

\Declaration{HallSubgroup}
\beginexample
gap> h:=SmallGroup(60,10);;
gap> u:=HallSubgroup(h,[2,3]);
Group([ f1, f2, f3 ])
gap> Size(u);
12
\endexample

\Declaration{SylowSystem}
\beginexample
gap> h:=SmallGroup(60,10);;
gap> SylowSystem(h);
[ Group( [ f1, f2 ] ), Group( [ f3 ] ), Group( [ f4 ] ) ]
gap> List(last,Size);
[ 4, 3, 5 ]
\endexample

\Declaration{ComplementSystem}
\beginexample
gap> ComplementSystem(h);
[ Group( [ f3, f4 ] ), Group( [ f1, f2, f4 ] ), Group( 
[ f1, f2, f3 ] ) ]
gap> List(last,Size);
[ 15, 20, 12 ]
\endexample

\Declaration{HallSystem}
\beginexample
gap> HallSystem(h);
[ Group( [] ), Group( [ f1, f2 ] ), Group( 
[ f1, f2, f3 ] ), Group( [ f1, f2, f3, f4 ] ), Group( 
[ f1, f2, f4 ] ), Group( [ f3 ] ), Group( 
[ f3, f4 ] ), Group( [ f4 ] ) ]
gap> List(last,Size);
[ 1, 4, 12, 60, 20, 3, 15, 5 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroups generated by prime powers}

\Declaration{Omega}
\beginexample
gap> h:=SmallGroup(16,10);
<pc group with 4 generators>
gap> Omega(h,2);
Group([ f4, f2, f3 ])
\endexample

\Declaration{Agemo}
\beginexample
gap> Agemo(h,2);Agemo(h,2,2);
Group([ f4, f2, f3 ])
Group([ f4, <identity> of ..., <identity> of ..., <identity> of ... ])
Group([ <identity> of ..., <identity> of ..., <identity> of ..., 
  <identity> of ... ])
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Normal Structure}

\index{normalizer}
\Declaration{Normalizer}
\beginexample
gap> Normalizer(g,Subgroup(g,[(1,2,3)]));
Group( [ (1,2,3), (2,3) ] )
\endexample

\Declaration{Core}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> Core(g,Subgroup(g,[(1,2,3,4)]));   
Group( () )
\endexample

\Declaration{PCore}
\beginexample
gap> PCore(g,2);
Group([ (1,2)(3,4), (1,3)(2,4) ])
\endexample

\Declaration{NormalClosure}
\beginexample
gap> NormalClosure(g,Subgroup(g,[(1,2,3)]));
Group( [ (1,2,3), (2,3,4) ] )
\endexample

\Declaration{NormalIntersection}
\beginexample
gap> NormalIntersection(Group((1,2)(3,4),(1,3)(2,4)),Group((1,2,3,4)));
Group([ (1,3)(2,4) ])
\endexample

\Declaration{Complementclasses}
\beginexample
gap> Complementclasses(g,Group((1,2)(3,4),(1,3)(2,4)));
[ Group( [ (3,4), (2,4,3) ] ) ]
\endexample

\Declaration{InfoComplement}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Properties}

Some of the properties can be defined not only for groups but also for other
structures. In this case the name got an added `Group' to distinguish it.

\Declaration{IsCyclic}
\Declaration{IsElementaryAbelian}
\Declaration{IsNilpotentGroup}
\Declaration{IsPerfectGroup}
\Declaration{IsSolvableGroup}
\Declaration{IsSupersolvableGroup}
\Declaration{IsMonomialGroup}

\Declaration{IsSimpleGroup}
\Declaration{IsomorphismTypeFiniteSimpleGroup}
\beginexample
gap> IsomorphismTypeFiniteSimpleGroup(Group((4,5)(6,7),(1,2,4)(3,5,6)));
rec( series := "L", parameter := [ 2, 7 ], name:=
  "A(1,7)=L(2,7)~B(1,7)=O(3,7)~C(1,7)=S(2,7)~2A(1,7)=U(2,7)~A(2,2)=L(3,2)")
\endexample

\Declaration{IsFinitelyGeneratedGroup}
\Declaration{IsSubsetLocallyFiniteGroup}

\index{p group}
\Declaration{IsPGroup}
\Declaration{PrimePGroup}
\Declaration{PClassPGroup}
\Declaration{RankPGroup}

The following are mathematical properties, but not {\GAP} `Properties' as
they are depending on a parameter:

\Declaration{IsPSolvable}

\Declaration{IsPNilpotent}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group Attributes}

\Declaration{AbelianInvariants}
\beginexample
gap> g:=Group((1,2,3,4),(1,2),(5,6));;
gap> AbelianInvariants(g);
[ 2, 2 ]
\endexample

\Declaration{Exponent}
\beginexample
gap> Exponent(g);
12
\endexample

Again the
following are mathematical attributes, but not {\GAP} `Attributes' as
they are depending on a parameter:

\Declaration{EulerianFunction}

\Declaration{PRump}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup Series}

In group theory many subgroup series are considered and {\GAP} provides
commands to compute them. In the following sections, there is always a
series $G=U_1>U_2>\cdots>U_m=\langle1\rangle$ of subgroups considered.
A series also may stop without reaching $G$ or $\langle1\rangle$.

A series is called ``subnormal'' if every $U_{i+1}$ is normal in $U_i$.

A series of normal subgroups is called ``central'' if $U_i/U_{i+1}$ is
central in $G/U_{i+1}$.

We call a series ``refinable'' if intermediate subgroups can be added to
the series without destroying the properties of the series.

\FileHeader[1]{grp}

\Declaration{ChiefSeries}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> ChiefSeries(g);
[ Group( [ (1,2,3,4), (1,2) ] ), 
  Group( [ (2,4,3), (1,4)(2,3), (1,2)(3,4) ] ), 
  Group( [ (1,2)(3,4), (1,3)(2,4) ] ), Group( () ) ]
\endexample

\Declaration{ChiefSeriesThrough}

\Declaration{ChiefSeriesUnderAction}

\Declaration{SubnormalSeries}
\beginexample
gap> s:=SubnormalSeries(g,Group((1,2,3)));
\endexample

\Declaration{CompositionSeries}

\Declaration{DisplayCompositionSeries}
\beginexample
gap> CompositionSeries(g);
[ Group( [ (3,4), (2,4,3), (1,4)(2,3), (1,2)(3,4) ] ), 
  Group( [ (2,4,3), (1,4)(2,3), (1,2)(3,4) ] ), 
  Group( [ (1,4)(2,3), (1,2)(3,4) ] ), Group( [ (1,2)(3,4) ] ), 
  Group( () ) ]
gap> DisplayCompositionSeries(g);
Group
 | Z(2)
Group
 | Z(3)
Group
 | Z(2)
Group
 | Z(2)
Group
\endexample

\Declaration{DerivedSeriesOfGroup}
\Declaration{DerivedLength}
\beginexample
gap> List(DerivedSeriesOfGroup(g),Size);
[ 24, 12, 4, 1 ]
gap> DerivedLength(g);
3
\endexample

\Declaration{ElementaryAbelianSeries}
\beginexample
\endexample

\Declaration{InvariantElementaryAbelianSeries}
\beginexample
gap> g:=Group((1,2,3,4),(1,3));
Group( [ (1,2,3,4), (1,3) ] )
gap> hom:=GroupHomomorphismByImages(g,g,GeneratorsOfGroup(g),
> [(1,4,3,2),(1,4)(2,3)]);
[ (1,2,3,4), (1,3) ] -> [ (1,4,3,2), (1,4)(2,3) ]
gap> InvariantElementaryAbelianSeries(g,[hom]);
[ Group( [ (1,2,3,4), (1,3) ] ), Group( [ (1,3)(2,4) ] ), Group( () ) ]
\endexample

\Declaration{LowerCentralSeriesOfGroup}

\Declaration{UpperCentralSeriesOfGroup}

\Declaration{PCentralSeries}

\Declaration{DimensionsLoewyFactors}

\Declaration{JenningsSeries}

\beginexample
gap> G:= SmallGroup( 3^6, 100 );
<pc group with 6 generators>
gap> JenningsSeries( G );
[ <pc group of size 729 with 6 generators>, Group([ f3, f4, f5, f6 ]), 
  Group([ f4, f5, f6 ]), Group([ f5, f6 ]), Group([ f5, f6 ]), 
  Group([ f5, f6 ]), Group([ f6 ]), Group([ f6 ]), Group([ f6 ]), Group([]) ]
\endexample

\Declaration{AscendingChain}

\Declaration{IntermediateGroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Factor Groups}

\Declaration{NaturalHomomorphismByNormalSubgroup}
\Declaration{FactorGroup}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;n:=Subgroup(g,[(1,2)(3,4),(1,3)(2,4)]);;
gap> hom:=NaturalHomomorphismByNormalSubgroup(g,n);
[ (3,4), (2,4,3), (1,2)(3,4), (1,3)(2,4) ] -> 
[ f1, f2, <identity> of ..., <identity> of ... ]
gap> FactorGroup(g,n);
<pc group with 2 generators>
\endexample

\Declaration{CommutatorFactorGroup}
\beginexample
gap> CommutatorFactorGroup(g);
<pc group with 1 generators>
\endexample

\Declaration{HasAbelianFactorGroup}
\Declaration{HasElementaryAbelianFactorGroup}
\beginexample
gap> HasAbelianFactorGroup(g,n);
false
gap> HasAbelianFactorGroup(DerivedSubgroup(g),n);  
true
\endexample

\Declaration{CentralizerModulo}
\beginexample
gap> CentralizerModulo(g,n,(1,2));
Group( [ (3,4), (1,4)(2,3), (1,3)(2,4) ] )
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Conjugacy Classes}

\Declaration{ConjugacyClass}
\Declaration{ConjugacyClasses}
\beginexample
gap> cl:=ConjugacyClasses(g);
[ ()^G, (3,4)^G, (2,3,4)^G, (1,2)(3,4)^G, (1,2,3,4)^G ]
gap> Representative(cl[3]);Centralizer(cl[3]);
(2,3,4)
Group([ (2,3,4) ])
gap> Size(Centralizer(cl[5]));
4
gap> Size(cl[2]);
6
\endexample

\Declaration{NrConjugacyClasses}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;                                        
gap> NrConjugacyClasses(g);
5
\endexample

\Declaration{IsConjugacyClassGroupRep}

\Declaration{RationalClass}
\Declaration{RationalClasses}
\beginexample
gap> RationalClasses(DerivedSubgroup(g));
[ RationalClass( Group( [ (1,3,2), (2,4,3) ] ), () ), 
  RationalClass( Group( [ (1,3,2), (2,4,3) ] ), (1,3)(2,4) ), 
  RationalClass( Group( [ (1,3,2), (2,4,3) ] ), (2,3,4) ) ]
\endexample
\Declaration{GaloisGroup}

\Declaration{IsConjugate}
\beginexample
gap> IsConjugate(g,Group((1,2,3,4),(1,3)),Group((1,3,2,4),(1,2)));
true
\endexample

`RepresentativeOperation' (see~"RepresentativeOperation") can be used to
obtain conjugating elements.
\beginexample
gap> RepresentativeOperation(g,(1,2),(3,4));
(1,3)(2,4)
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Sets of Subgroups}

\Declaration{ConjugacyClassSubgroups}
\beginexample
gap> g:=Group((1,2,3,4),(1,2));;IsNaturalSymmetricGroup(g);;
gap> cl:=ConjugacyClassSubgroups(g,Subgroup(g,[(1,2)]));
Group( [ (1,2) ] )^G
gap> Size(cl);
6
gap> cl[4];
Group( [ (2,4) ] )
\endexample

\Declaration{IsConjugacyClassSubgroupsRep}

\Declaration{ConjugacyClassesSubgroups}
\beginexample
gap> ConjugacyClassesSubgroups(g);
[Group(())^G,Group([(1,4)(2,3)])^G,Group([(1,4)(2,3),(1,3)(2,4)])^G,
# [omitted]
Group([(1,2)(3,4),(1,2)])^G,Group([(1,2)(3,4),(1,3,2,4)])^G]
\endexample

\Declaration{ConjugacyClassesMaximalSubgroups}
\beginexample
gap> ConjugacyClassesMaximalSubgroups(g);
[Group([(2,4,3),(1,4)(2,3),(1,2)(3,4)])^G,
 Group([(3,4),(1,4)(2,3),(1,2)(3,4)])^G, Group([(3,4),(2,4,3)])^G]
\endexample

\Declaration{MaximalSubgroupClassReps}
\beginexample
gap> MaximalSubgroupClassReps(g);   
[ Group( [ (2,4,3), (1,4)(2,3), (1,2)(3,4) ] ), Group( 
[ (3,4), (1,4)(2,3), (1,2)(3,4) ] ), Group( [ (3,4), (2,4,3) 
 ] ) ]
\endexample

\Declaration{MaximalSubgroups}
\beginexample
gap> MaximalSubgroups(Group((1,2,3),(1,2)));
[ Group( [ (1,2,3) ] ), Group( [ (2,3) ] ), Group( 
[ (1,3) ] ), Group( [ (1,2) ] ) ]
\endexample

\Declaration{NormalSubgroups}
\beginexample
gap> NormalSubgroups(g);
[Group(()),Group([(1,2)(3,4),(1,3)(2,4)]),
Group([(2,4,3),(1,4)(2,3),(1,2)(3,4)]),Sym([1..4])]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Subgroup Lattice}

\Declaration{LatticeSubgroups}
\beginexample
gap> g:=SymmetricGroup(4);;
gap> l:=LatticeSubgroups(g);
LatticeSubgroups(SymmetricGroup( [ 1 .. 4 ] ),# 11 classes, 30 subgroups)
\endexample

\Declaration{MaximalSubgroupsLattice}
\beginexample
gap> MaximalSubgroupsLattice(l);
[ [  ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], [ [ 1, 1 ] ], 
  [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ] ], [ [ 3, 1 ], [ 3, 6 ], [ 2, 1 ] ], 
  [ [ 2, 1 ] ], [ [ 4, 1 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ] ], 
  [ [ 7, 1 ], [ 6, 1 ], [ 5, 1 ] ], 
  [ [ 5, 1 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ], 
  [ [ 10, 1 ], [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 8, 1 ], [ 8, 2 ], [ 8, 3 ], 
      [ 8, 4 ] ] ]
gap> last[6];
[ [ 3, 1 ], [ 3, 6 ], [ 2, 1 ] ]
gap> u1:=Representative(ConjugacyClassesSubgroups(l)[6]);
Group( [ (3,4), (1,2) ] )
gap> u2:=ConjugacyClassesSubgroups(l)[3][1];;
gap> u3:=ConjugacyClassesSubgroups(l)[3][6];;
gap> u4:=ConjugacyClassesSubgroups(l)[2][1];;
gap> IsSubgroup(u1,u2);IsSubgroup(u1,u3);IsSubgroup(u1,u4);
true
true
true
\endexample

\Declaration{MinimalSupergroupsLattice}
\beginexample
gap> MinimalSupergroupsLattice(l); 
[ [ [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ], 
      [ 3, 5 ], [ 3, 6 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ] ], 
  [ [ 5, 1 ], [ 6, 1 ], [ 7, 1 ] ], [ [ 6, 1 ], [ 8, 1 ], [ 8, 2 ] ], 
  [ [ 8, 1 ], [ 10, 1 ] ], [ [ 9, 1 ], [ 9, 2 ], [ 9, 3 ], [ 10, 1 ] ], 
  [ [ 9, 1 ] ], [ [ 9, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], [ [ 11, 1 ] ], 
  [  ] ]
gap> last[3];
[ [ 6, 1 ], [ 8, 1 ], [ 8, 2 ] ]
gap> u5:=ConjugacyClassesSubgroups(l)[8][1];
Group( [ (2,4,3), (3,4) ] )
gap> u6:=ConjugacyClassesSubgroups(l)[8][2];
Group( [ (1,3,4), (3,4) ] )
gap> IsSubgroup(u5,u2);
true
gap> IsSubgroup(u6,u2);
true
\endexample

\Declaration{RepresentativesPerfectSubgroups}
\beginexample
gap> m11:=TransitiveGroup(11,6);
M(11)
gap> RepresentativesPerfectSubgroups(m11);
[ Group([(1,3)(2,5)(4,7)(10,11),(2,3,7)(4,11,9)(5,8,10)]),
  Group([(1,3)(2,5)(4,7)(10,11),(2,3,8)(4,11,10)(6,9,7)]), 
  Group([(1,11)(2,7)(5,9)(6,10),(1,5,4)(2,11,8)(7,9,10),
         (1,8,5)(4,6,9)(7,10,11)]),
  Group([(1,3)(2,5)(4,7)(10,11),(2,3,10)(5,8,7)(6,9,11)]),
  M(11),Group(()) ]
\endexample

\Declaration{ConjugacyClassesPerfectSubgroups}
\beginexample
gap> ConjugacyClassesPerfectSubgroups(m11);
[ Group([(1,3)(2,5)(4,7)(10,11), (2,3,7)(4,11,9)(5,8,10)])^G,
  Group([(1,3)(2,5)(4,7)(10,11), (2,3,8)(4,11,10)(6,9,7)])^G,
  Group([(1,11)(2,7)(5,9)(6,10), (1,5,4)(2,11,8)(7,9,10),
         (1,8,5)(4,6,9)(7,10,11)])^G,
  Group([(1,3)(2,5)(4,7)(10,11), (2,3,10)(5,8,7)(6,9,11)])^G,
  M(11)^G, Group(())^G ]
\endexample

\Declaration{Zuppos}

\Declaration{InfoLattice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Specific Methods for Subgroup Lattice Computations}

\Declaration{LatticeByCyclicExtension}
\beginexample
gap> g:=WreathProduct(Group((1,2,3),(1,2)),Group((1,2,3,4)));;
gap> l:=LatticeByCyclicExtension(g,function(G)
> return Size(G) in [1,2,3,6];end);
LatticeSubgroups(Group( [ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8), 
  (10,11,12), (10,11), ( 1, 4, 7,10)( 2, 5, 8,11)( 3, 6, 9,12) ] ),# 
47 classes, 2628 subgroups)
\endexample

\Declaration{InvariantSubgroupsElementaryAbelianGroup}
\beginexample
gap> g:=Group((1,2,3),(4,5,6),(7,8,9));
Group( [ (1,2,3), (4,5,6), (7,8,9) ] )
gap> hom:=GroupHomomorphismByImages(g,g,[(1,2,3),(4,5,6),(7,8,9)], 
> [(7,8,9),(1,2,3),(4,5,6)]);
[ (1,2,3), (4,5,6), (7,8,9) ] -> [ (7,8,9), (1,2,3), (4,5,6) ]
gap> u:=InvariantSubgroupsElementaryAbelianGroup(g,[hom]);
[ Group( () ), Group( [ (1,2,3)(4,5,6)(7,8,9) ] ), Group( 
[ (1,3,2)(7,8,9), (1,3,2)(4,5,6) ] ), Group( 
[ (7,8,9), (4,5,6), (1,2,3) ] ) ]
\endexample

\Declaration{SubgroupsSolvableGroup}
\beginexample
gap> g:=Group((1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8));                   
Group( [ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ] )
gap> hom:=GroupHomomorphismByImages(g,g,                                    
> [(1,2,3),(1,2),(4,5,6),(4,5),(7,8,9),(7,8)],
> [(4,5,6),(4,5),(7,8,9),(7,8),(1,2,3),(1,2)]);
[ (1,2,3), (1,2), (4,5,6), (4,5), (7,8,9), (7,8) ] -> 
[ (4,5,6), (4,5), (7,8,9), (7,8), (1,2,3), (1,2) ]
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom]));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 2, 6, 18, 108, 4, 216, 8 ]
gap> Length(ConjugacyClassesSubgroups(g)); # to compare
162
\endexample

\Declaration{SizeConsiderFunction}
\beginexample
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],    
> consider:=SizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 18, 108, 216 ]
\endexample
This example shows that in general the `consider' function does not provide
a perfect filter. It is guaranteed that all subgroups fulfilling the
condition are retuirned, but not all subgroups returned necessarily fulfill
the condition.

\Declaration{ExactSizeConsiderFunction}
\beginexample
gap> l:=SubgroupsSolvableGroup(g,rec(actions:=[hom],
> consider:=ExactSizeConsiderFunction(6)));;
gap> List(l,Size);
[ 1, 3, 9, 27, 54, 6, 108, 216 ]
\endexample

\Declaration{InfoPcSubgroup}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Special Generating Sets}

\Declaration{GeneratorsSmallest}
\beginexample
gap> g:=SymmetricGroup(4);;
gap> GeneratorsSmallest(g);
[ (3,4), (2,3), (1,2) ]
\endexample
\Declaration{LargestElementGroup}

\Declaration{MinimalGeneratingSet}
\beginexample
gap> MinimalGeneratingSet(g);
[ (2,4,3), (1,4,2,3) ]
\endexample

\Declaration{SmallGeneratingSet}
\beginexample
gap> SmallGeneratingSet(g);
[ (2,4,3), (1,4,2,3) ]
\endexample

\Declaration{IndependentGeneratorsOfAbelianGroup}
\beginexample
gap> g:=AbelianGroup(IsPermGroup,[15,14,22,78]);;
gap> List(IndependentGeneratorsOfAbelianGroup(g),Order);
[ 2, 2, 2, 3, 3, 5, 7, 11, 13 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{1-Cohomology}

\index{one cohomology}
\index{cohomology}
\index{cocycles}

Let $G$ be a finite group and  $M$ an elementary abelian normal $p$-subgroup
of $G$.  Then the group of 1-coboundaries $B^1( G/M, M )$ is defined as

%display{tex}
$$
B^1( G/M, M ) = \{ \gamma : G/M \rightarrow M \; ; \; \exists m\in M\;\;\forall
		g\in G : \gamma( gM ) = (m^{-1})^g \cdot m \}
$$
%display{text}
% B^1(G/M,M)={ y: G/M -> M | There is a m in M such that for all g in G
%                              y(gM)=m^-1*g*m   holds }
%enddisplay
It is a $GF(p)$-vector space.  The group  of cocycles $Z^1(  G/M, M  )$ is
defined as
%display{tex}
$$
Z^1( G/M, M ) = \{ \gamma : G/M \rightarrow M \; ; \; \forall
		g_1, g_2\in G :
		\gamma(g_1M \cdot g_2M ) =
		\gamma(g_1M)^{g_2} \cdot \gamma(g_2M) \}
$$
%display{text}
% Z^1(G/M,M)={ y: G/M -> M | For all g1,g2 in G holds: 
%                             y(g1 M * g2 M)= y(g1 M)^g2 * y(g2 M)
%enddisplay

and is also a $GF(p)$-vector space.

Let $\alpha$ be the isomorphism of $M$ into a row vector space ${\cal W}$
and $(g_1,   ..., g_l)$ representatives for  a  generating set  of $G/M$.
Then  there exists a  monomorphism   $\beta$ of $Z^1(   G/M, M )$  in the
$l$-fold direct sum of ${\cal W}$, such that $\beta( \gamma ) = ( \alpha(
\gamma( g_1M ) ), ..., \alpha( \gamma( g_lM ) ) )$  for  every $\gamma\in
Z^1( G/M, M )$.

\Declaration{OneCocycles}
\Declaration{OneCoboundaries}

The operations `OneCocycles' and `OneCoboundaries' return a record with
(at least) the components:

\beginitems
`generators'&
Is a list of representatives for a generating set of $G/M$. Cocycles are
represented with respect to these generators.

`oneCocycles'&
A space of row vectors over GF($p$), representing $Z^1$. The vectors are
represented in dimension $a\cdot b$ where $a$ is the length of `generators'
and $p^b$ the size of $M$.

`oneCoboundaries'&
A space of row vectors that represents $B^1$.

`cocycleToList'&
is a function to convert a cocycle (a row vector in `oneCocycles') to
a corresponding list of elements of $M$.

`listToCocycle'&
is a function to convert a list of elements of $M$ to a cocycle.

`isSplitExtension'&
indicates whether $G$ splits over $M$.
The following components are only bound if the extension splits. Note that
if $M$ is given by a modulo pcgs all subgroups are given as subgroups of $G$
by generators corresponding to `generators' and thus may not contain the
denominator of the modulo pcgs. In this case taking the closure with this
denominator will give the full preimage of the complement in the factor
group.

`complement'&
One complement to $M$ in $G$.

`cocycleToComplement(<cyc>)'&
is a function that takes a cocycle from `oneCocycles' and returns the
corresponding complement to $M$ in $G$ (with respect to the fixed complement
`complement').

`complementToCocycle(<U>)'&
is a function that takes a complement and returns the corresponding cocycle.

\enditems

If the factor <G>/<M> is given by a (modulo) pcgs <gens> then special
methods are used that compute a presentation for the factor implicitly from
the pcgs.

Note that 1-cocycles and `-coboundaries are not `Group's in the sense of
{\GAP} but vector spaces.

\beginexample
gap> g:=Group((1,2,3,4),(1,2));;
gap> n:=Group((1,2)(3,4),(1,3)(2,4));;
gap> oc:=OneCocycles(g,n);
rec(
  oneCoboundaries := VectorSpace( GF(2), 
    [ [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] 
     ] ),
  oneCocycles := VectorSpace( GF(2), [ [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ], 
      [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ] ),
  generators := [ (3,4), (2,4,3) ],
  isSplitExtension := true,
  complement := Group( [ (3,4), (2,4,3) ] ),
  cocycleToList := function ( c ) ... end,
  listToCocycle := function ( L ) ... end,
  cocycleToComplement := function ( c ) ... end,
  factorGens := [ (3,4), (2,4,3) ],
  complementToCocycle := function ( K ) ... end )
gap> oc.cocycleToList([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
[ (1,2)(3,4), (1,2)(3,4) ]
gap> oc.listToCocycle([(),(1,3)(2,4)]);
[ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]
gap> oc.cocycleToComplement([ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]);
Group( [ (1,2), (1,2,3) ] )
gap> oc.cocycleToComplement([ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ]);
Group( [ (3,4), (1,3,4) ] )
gap> oc.complementToCocycle(Group((1,2,4),(1,4)));
[ 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0 ]
\endexample

The factor group $H^1(G/M,M)=Z^1(G/M,M)/B^1(G/M,M)$ is called the first
cohomology group. Currehntly there is no function which explicitly computes
this group. The easiest way to represent is as a vector space complement to
$B^1$ in $Z^1$.

{}

Sometimes it might be desirable to stop calculations in the non-splitting
case if only complements are desired. This
can be done via the more technical function `OCOneCocycles'.
\Declaration{OCOneCocycles}

\Declaration{ComplementclassesEA}

\Declaration{InfoCoh}

% \Section{AutomorphisGroups and Testing Isomorphism}
%T Is dealed with in section on group homomorphisms!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tests for the Availability of Methods}

\FileHeader{grp}[3]

\Declaration{CanEasilyTestMembership}
\Declaration{CanComputeSize}
\Declaration{CanComputeIndex}
\Declaration{CanComputeIsSubset}
\Declaration{KnowsHowToDecompose}

