%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  vector.msk                  GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\Chapter{Row Vectors}

Just as in mathematics, a vector in {\GAP} is any object which
supports appropriate addition and scalar multiplication operations
(see "Vector Spaces"). As in mathematics, an especially important
class of vectors are those represented by a list of coefficients with
respect to some basis. These are called *row vectors*.

\Declaration{IsRowVector}
\beginexample
gap> IsRowVector([1,2,3]);
true
\endexample

Because row vectors are just a special case of lists, all operations
and functions for lists are applicable to row vectors as well (see
chapter "Lists"). This especially includes accessing elements of a row
vector (see "List Elements"), changing elements of a mutable row
vector (see "List Assignment"), and comparing row vectors (see
"Comparisons of Lists").

Note that, unless your algorithms specifically require you to be able
to change entries of your vectors, it is generally better and faster
to work with immutable row vectors. See section "Mutability and
Copyability" for more details.

%%  The basic design of the row vector support in {\GAP} 4 is due to
%%  Martin Sch{\"o}nert. Frank Celler added the special support for
%%  vectors over the field of two elements; Steve Linton added special
%%  support for vectors over fields of sizes between 3 and 256; and Werner
%%  Nickel added special methods for vectors over large finite fields.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operators for Row Vectors}

Since row vectors are lists, the arithmetic operations have the same
definitions as for lists, which we nevertheless recall here, in the
language of vectors.

\>`<vec1> + <vec2>'{vector!addition} O

returns the sum of the two vectors <vec1> and <vec2>, which must have the
same length and be defined over a common field. The sum is a new vector
where each entry is the sum of the corresponding entries of the vectors. As
an exception it is also possible to add an integer vector to a vector over
the finite field <F>, in which case the integers are interpreted as
`<scalar> \*\ One(<F>)'.

\>`<scalar> + <vec>'{scalar!addition} O
\>`<vec> + <scalar>'{scalar!addition} O

returns a new vector where each entry is the sum of the scalar and the
corresponding entry of the vector. The elements of <vec> must lie in a
common field with <scalar>.  As an exception it is also possible to add an
integer scalar to a vector over the finite field <F>, in which case the
integer is interpreted as `<scalar> \* One(<F>)'.

\beginexample
gap> [ 1, 2, 3 ] + [ 1/2, 1/3, 1/4 ];
[ 3/2, 7/3, 13/4 ]
gap>  [ 1/2, 3/2, 1/2 ] + 1/2;
[ 1, 2, 1 ]
\endexample

\>`<vec1> - <vec2>'{vector!subtraction} O
\>`<scalar> - <vec>'{scalar!subtraction} O
\>`<vec> - <scalar>'{scalar!subtraction} O

The difference operator `-' returns the componentwise difference of its
two operands and is defined subject to the same restrictions as `+'.

\beginexample
gap> [ 1, 2, 3 ] - [ 1/2, 1/3, 1/4 ];
[ 1/2, 5/3, 11/4 ]
gap> [ 1/2, 3/2, 1/2 ] - 1/2;
[ 0, 1, 0 ]
\endexample

\>`<vec1> * <vec2>'{scalar product} O

returns the standard scalar product of <vec1> and <vec2>, which must have
the same length and be defined over the same field.
The product is the sum of the products of the
corresponding entries of the vectors. As an exception it is also
possible to multiply an integer vector to a finite field vector, in which
case the integers are interpreted as `<scalar> * One(<GF>)'.

\>`<scalar> * <vec>'{scalar!multiplication} O
\>`<vec> * <scalar>'{scalar!multiplication} O

returns the product of <scalar> and <vector>. 
The elements of <vec> must lie in a common field with <scalar>.
The product is a new
vector where each entry is the product of the scalar and the
corresponding entry of the vector. As an exception it is also possible
to multiply an integer scalar to a finite field vector, in which case the
integer is interpreted as `<scalar> * One(<GF>)'.

\beginexample
gap> [ 1, 2, 3 ] * [ 1/2, 1/3, 1/4 ];
23/12
gap> [ 1/2, 3/2, 1/2 ] * 2;
[ 1, 3, 1 ]
\endexample

For the mutability of results of arithmetic operations,
see~"Mutability and Copyability".

Further operations with vectors as operands are defined by the matrix
operations (see~"Operators for Matrices").

\Declaration{NormedRowVector}
\beginexample
gap> NormedRowVector([5,2,3]);
[ 1, 2/5, 3/5 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Row Vectors over Finite Fields}

{\GAP} uses a compact formats to store row vectors over fields of
order at most 256, based on those used by the Meat-Axe
\cite{Rin93}. This format also permits extremely efficient vector
arithmetic. On the other hand element access and assignment is
significantly slower than for plain lists.

Under some circumstances, for example if a list is entered on the
command line, or made from the empty list by asssigning the positions
in increasing order, then {\GAP} will automatically realise that it is 
vector over a small finite field, and represent it accordingly.

\beginexample
gap> [Z(2)]; 
<a GF2 vector of length 1>
gap> [Z(3),Z(9),Z(3)^2,Z(9)^4,Z(9)^3,Z(9)^7,Z(9)^2,Z(9)^5,Z(9),Z(3),Z(3)];
< mutable compressed vector length 11 over GF(9) >
gap> 
gap> l := [];
[  ]
gap> l[1] := Z(2);
Z(2)^0
gap> l;        
<a GF2 vector of length 1>
gap> l[2] := Z(4);
Z(2^2)
gap> l;
[ Z(2)^0, Z(2^2) ]
gap> RepresentationsOfObject(l);
[ "IsDataObjectRep", "Is8BitVectorRep" ]
\endexample

A vector in the special representation over $GF(2)$ is always viewed
as `\<a GF2 vector of length ...>'. Over fields of orders 3 to 256, a
vector of length 10 or less is viewed as the list of its coefficients, 
but a longer one is abbreviated.

There are some situations where {\GAP} cannot efficiently detect that
a list has become a row vector over a finite field. The function
`ConvertToVectorRep' will handle these situations.

\Declaration{ConvertToVectorRep}

In this example, we first creat a row vector ``by stealth'' and then
force {\GAP} to rewrite it, first over GF(2) and then over GF(4).

\beginexample
gap> v := [1,Z(2),Z(2),0*Z(2)];
[ 1, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> v[1] := Z(2);
Z(2)^0
gap> v;           
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IS_PLIST_REP", "IsInternalRep" ]
gap> ConvertToVectorRep(v);
2
gap> v;
<a GF2 vector of length 4>
gap> ConvertToVectorRep(v,4);
4
gap> v;
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IsDataObjectRep", "Is8BitVectorRep" ]
\endexample




\Declaration{NumberFFVector}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Coefficient List Arithmetic}

\FileHeader{listcoef}[1]
\Declaration{AddRowVector}

\Declaration{AddCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;AddCoeffs(l,m);
4
gap> l;
[ 6, 8, 10, 4 ]
\endexample

\Declaration{MultRowVector}

\Declaration{CoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;CoeffsMod(l,2);
[ 1, 0, 1 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Shifting and Trimming Coefficient Lists}

\FileHeader{listcoef}[3]
\Declaration{LeftShiftRowVector}
\Declaration{RightShiftRowVector}
\Declaration{ShrinkRowVector}

\Declaration{RemoveOuterCoeffs}
\beginexample
gap> l:=[1,1,2,1,2,1,1,2,1];;RemoveOuterCoeffs(l,1);
2
gap> l;
[ 2, 1, 2, 1, 1, 2 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for Coding Theory}

\FileHeader{listcoef}[4]

\Declaration{WeightVecFFE}
\Declaration{DistanceVecFFE}
\Declaration{DistancesDistributionVecFFEsVecFFE}
\Declaration{DistancesDistributionMatFFEVecFFE}
\Declaration{AClosestVectorCombinationsMatFFEVecFFE}
\Declaration{CosetLeadersMatFFE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Vectors as coefficients of polynomials}


A list of ring elements can be interpreted as a row vector or the list of
coefficients of a polynomial. There are a couple of functions that implement
arithmetic operations based on these interpretations. {\GAP} contains proper
support for polynomials (see~"Polynomials and Rational Functions"), the
operations described in this section are on a lower level.

\FileHeader{listcoef}[2]

\Declaration{ValuePol}
\beginexample
gap> ValuePol([1,2,3],4);
57
\endexample

%\ Declaration{ProductPol}
%\ beginexample
%gap> ProductPol([1,2,3],[4,5,6]);
%[ 4, 13, 28, 27, 18 ]
%\ endexample

%\ Declaration{MultCoeffs}
%\ beginexample
%gap> a:=[];;l:=[1,2,3,4];;m:=[5,6,7];;
%gap> MultCoeffs(a,l,4,m,3);
%6
%gap> a;
%[ 5, 16, 34, 52, 45, 28 ]
%\ endexample

\Declaration{ProductCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ProductCoeffs(l,m);   
[ 5, 16, 34, 52, 45, 28 ]
\endexample

\Declaration{ReduceCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffs(l,m); 
2
gap> l;
[ 64/49, -24/49, 0, 0 ]
\endexample

\Declaration{ReduceCoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffsMod(l,m,3);
1
gap> l;
[ 1, 0, 0, 0 ]
\endexample

\Declaration{PowerModCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;PowerModCoeffs(l,5,m); 
[ -839462813696/678223072849, -7807439437824/678223072849, 0 ]
\endexample

\Declaration{ShiftedCoeffs}
\beginexample
gap> l:=[1,2,3];;ShiftedCoeffs(l,2);ShiftedCoeffs(l,-2);    
[ 0, 0, 1, 2, 3 ]
[ 3 ]
\endexample

\Declaration{ShrinkCoeffs}
\beginexample
gap> l:=[1,0,0];;ShrinkCoeffs(l);l;
1
[ 1 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

