%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  vector.msk                  GAP documentation            Martin Schoenert
%A                                                           Alexander Hulpke
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%Y  Copyright (C) 2002 The GAP Group
%%
\Chapter{Row Vectors}

Just as in mathematics, a vector in {\GAP} is any object which
supports appropriate addition and scalar multiplication operations
(see Chapter~"Vector Spaces"). As in mathematics, an especially important
class of vectors are those represented by a list of coefficients with
respect to some basis. These correspond roughly to the {\GAP} concept
of *row vectors*.

\Declaration{IsRowVector}
\beginexample
gap> IsRowVector([1,2,3]);
true
\endexample

Because row vectors are just a special case of lists, all operations
and functions for lists are applicable to row vectors as well (see
Chapter~"Lists"). This especially includes accessing elements of a row
vector (see "List Elements"), changing elements of a mutable row
vector (see "List Assignment"), and comparing row vectors (see
"Comparisons of Lists").

Note that, unless your algorithms specifically require you to be able
to change entries of your vectors, it is generally better and faster
to work with immutable row vectors. See Section~"Mutability and
Copyability" for more details.

%%  The basic design of the row vector support in {\GAP} 4 is due to
%%  Martin Sch{\"o}nert. Frank Celler added the special support for
%%  vectors over the field of two elements; Steve Linton added special
%%  support for vectors over fields of sizes between 3 and 256; and Werner
%%  Nickel added special methods for vectors over large finite fields.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operators for Row Vectors}

The rules for arithmetic operations involving row vectors are in fact
special cases of those for the arithmetic of lists,
as given in Section~"Arithmetic for Lists" and the following sections,
here we reiterate that definition, in the language of vectors.

Note that the additive behaviour sketched below is defined only for lists in
the category `IsGeneralizedRowVector',
and the multiplicative behaviour is defined only for lists in the category
`IsMultiplicativeGeneralizedRowVector'
(see~"Filters Controlling the Arithmetic Behaviour of Lists").


\>`<vec1> + <vec2>'{addition!vectors} O

returns the sum of the two row vectors <vec1> and <vec2>.
Probably the most usual situation is that <vec1> and <vec2> have the same
length and are defined over a common field;
in this case the sum is a new row vector over the same field where each entry
is the sum of the corresponding entries of the vectors.

In more general situations, the sum of two row vectors need not be a row
vector, for example adding an integer vector <vec1> and a vector <vec2> over
a finite field yields the list of pointwise sums,
which will be a mixture of finite field elements and integers if <vec1> is
longer than <vec2>.


\>`<scalar> + <vec>'{addition!scalar and vector} O
\>`<vec> + <scalar>'{addition!vector and scalar} O

returns the sum of the scalar <scalar> and the row vector <vec>.
Probably the most usual situation is that the elements of <vec> lie in a
common field with <scalar>;
in this case the sum is a new row vector over the same field where each entry
is the sum of the scalar and the corresponding entry of the vector.

More general situations are for example the sum of an integer scalar and a
vector over a finite field, or the sum of a finite field element and an
integer vector.

\beginexample
gap> [ 1, 2, 3 ] + [ 1/2, 1/3, 1/4 ];
[ 3/2, 7/3, 13/4 ]
gap>  [ 1/2, 3/2, 1/2 ] + 1/2;
[ 1, 2, 1 ]
\endexample


\>`<vec1> - <vec2>'{subtraction!vectors} O
\>`<scalar> - <vec>'{subtraction!scalar and vector} O
\>`<vec> - <scalar>'{subtraction!vector and scalar} O

Subtracting a vector or scalar is defined as adding its additive inverse,
so the statements for the addition hold likewise.

\beginexample
gap> [ 1, 2, 3 ] - [ 1/2, 1/3, 1/4 ];
[ 1/2, 5/3, 11/4 ]
gap> [ 1/2, 3/2, 1/2 ] - 1/2;
[ 0, 1, 0 ]
\endexample


\>`<scalar> * <vec>'{multiplication!scalar and vector} O
\>`<vec> * <scalar>'{multiplication!vector and scalar} O

returns the product of the scalar <scalar> and the row vector <vec>.
Probably the most usual situation is that the elements of <vec> lie in a
common field with <scalar>;
in this case the product is a new row vector over the same field where each
entry is the product of the scalar and the corresponding entry of the vector.

More general situations are for example the product of an integer scalar and
a vector over a finite field,
or the product of a finite field element and an integer vector.

\beginexample
gap> [ 1, 2, 3 ] * [ 1/2, 1/3, 1/4 ];
23/12
gap> [ 1/2, 3/2, 1/2 ] * 2;
[ 1, 3, 1 ]
\endexample


\>`<vec1> * <vec2>'{multiplication!vectors} O

returns the standard scalar product of <vec1> and <vec2>,
i.e., the sum of the products of the corresponding entries of the vectors.
Probably the most usual situation is that <vec1> and <vec2> have the same
length and are defined over a common field;
in this case the sum is an element of this field.

More general situations are for example the inner product of an integer
vector and a vector over a finite field,
or the inner product of two row vectors of different lengths.

For the mutability of results of arithmetic operations,
see~"Mutability and Copyability".

Further operations with vectors as operands are defined by the matrix
operations (see~"Operators for Matrices").

\Declaration{NormedRowVector}
\beginexample
gap> NormedRowVector([5,2,3]);
[ 1, 2/5, 3/5 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Row Vectors over Finite Fields}

{\GAP} can use compact formats to store row vectors over fields of
order at most 256, based on those used by the Meat-Axe
\cite{Rin93}. This format also permits extremely efficient vector
arithmetic. On the other hand element access and assignment is
significantly slower than for plain lists.

The function `ConvertToVectorRep' is used to convert a list into a
compressed vector, or to rewrite a compressed vector over another
field. Note that this function is *much* faster when it is given a
field (or field size) as an argument, rather than having to scan the
vector and try to decide the field. Supplying the field can also
avoid errors and/or loss of performance, when one vector from some
collection happens to have all of its entries over a smaller field
than the \"natural\" field of the problem.

\Declaration{ConvertToVectorRep}

In this example, we first create a row vector and then ask {\GAP} to
rewrite it, first over GF(2) and then over GF(4).

\beginexample
gap> v := [Z(2)^0,Z(2),Z(2),0*Z(2)];
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IS_PLIST_REP", "IsInternalRep" ]
gap> ConvertToVectorRep(v);
2
gap> v;
<a GF2 vector of length 4>
gap> ConvertToVectorRep(v,4);
4
gap> v;
[ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
gap> RepresentationsOfObject(v);
[ "IsDataObjectRep", "Is8BitVectorRep" ]
\endexample

A vector in the special representation over $GF(2)$ is always viewed
as `\<a GF2 vector of length ...>'. Over fields of orders 3 to 256, a
vector of length 10 or less is viewed as the list of its coefficients,
but a longer one is abbreviated.

Arithmetic operations (see~"Arithmetic for Lists" and the following
sections) preserve the compression status of row vectors in the sense that
if all arguments are compressed row vectors written over the same field and
the result is a row vector then also the result is a compressed row vector
written over this field.

\Declaration{NumberFFVector}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Coefficient List Arithmetic}

\FileHeader{listcoef}[1]
\Declaration{AddRowVector}

\Declaration{AddCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;AddCoeffs(l,m);
4
gap> l;
[ 6, 8, 10, 4 ]
\endexample

\Declaration{MultRowVector}

\Declaration{CoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;CoeffsMod(l,2);
[ 1, 0, 1 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Shifting and Trimming Coefficient Lists}

\FileHeader{listcoef}[3]
\Declaration{LeftShiftRowVector}
\Declaration{RightShiftRowVector}
\Declaration{ShrinkRowVector}

\Declaration{RemoveOuterCoeffs}
\beginexample
gap> l:=[1,1,2,1,2,1,1,2,1];;RemoveOuterCoeffs(l,1);
2
gap> l;
[ 2, 1, 2, 1, 1, 2 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for Coding Theory}

\FileHeader{listcoef}[4]

\Declaration{WeightVecFFE}
\Declaration{DistanceVecFFE}
\Declaration{DistancesDistributionVecFFEsVecFFE}
\Declaration{DistancesDistributionMatFFEVecFFE}
\Declaration{AClosestVectorCombinationsMatFFEVecFFE}
\Declaration{CosetLeadersMatFFE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Vectors as coefficients of polynomials}


A list of ring elements can be interpreted as a row vector or the list of
coefficients of a polynomial. There are a couple of functions that implement
arithmetic operations based on these interpretations. {\GAP} contains proper
support for polynomials (see~"Polynomials and Rational Functions"), the
operations described in this section are on a lower level.

\FileHeader{listcoef}[2]

\Declaration{ValuePol}
\beginexample
gap> ValuePol([1,2,3],4);
57
\endexample

%\ Declaration{ProductPol}
%\ beginexample
%gap> ProductPol([1,2,3],[4,5,6]);
%[ 4, 13, 28, 27, 18 ]
%\ endexample

%\ Declaration{MultCoeffs}
%\ beginexample
%gap> a:=[];;l:=[1,2,3,4];;m:=[5,6,7];;
%gap> MultCoeffs(a,l,4,m,3);
%6
%gap> a;
%[ 5, 16, 34, 52, 45, 28 ]
%\ endexample

\Declaration{ProductCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ProductCoeffs(l,m);
[ 5, 16, 34, 52, 45, 28 ]
\endexample

\Declaration{ReduceCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffs(l,m);
2
gap> l;
[ 64/49, -24/49, 0, 0 ]
\endexample

\Declaration{ReduceCoeffsMod}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;ReduceCoeffsMod(l,m,3);
1
gap> l;
[ 1, 0, 0, 0 ]
\endexample

\Declaration{PowerModCoeffs}
\beginexample
gap> l:=[1,2,3,4];;m:=[5,6,7];;PowerModCoeffs(l,5,m);
[ -839462813696/678223072849, -7807439437824/678223072849, 0 ]
\endexample

\Declaration{ShiftedCoeffs}
\beginexample
gap> l:=[1,2,3];;ShiftedCoeffs(l,2);ShiftedCoeffs(l,-2);
[ 0, 0, 1, 2, 3 ]
[ 3 ]
\endexample

\Declaration{ShrinkCoeffs}
\beginexample
gap> l:=[1,0,0];;ShrinkCoeffs(l);l;
1
[ 1 ]
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E

