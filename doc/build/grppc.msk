%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  grppc.msk                   GAP documentation            Alexander Hulpke
%A                                                               Bettina Eick
%%
%A  @(#)$Id$
%%
%Y  (C) 1998 School Math and Comp. Sci., University of St.  Andrews, Scotland
%%
\PreliminaryChapter{Pc Groups}

Let $G$ be a polycyclic group with pcgs $P = (g_1, \ldots, g_n)$
and corresponding relative orders $(r_1, \ldots, r_n)$. Recall that the
$r_i$ are positive integers or infinity and let $I$ be the set of indices
$i$ with $r_i$ a positive integer. Then $G$ has a finite presentation
on the generators $g_1, \ldots, g_n$ with relations of the following
form.

$$ g_i^{r_i} = g_{i+1}^{a(i,i,i+1)} \cdots g_n^{a(i,i,n)} 
   \hbox{ for } 1 \leq i \leq n \hbox{ with } i \in I$$
$$ g_i^{-1} g_j g_i = g_{i+1}^{a(i,j,i+1)} \cdots g_n^{a(i,j,n)} 
   \hbox{ for } 1 \leq i \< j \leq n$$

For infinite groups we need additionally

$$ g_i^{-1} g_j^{-1} g_i = g_{i+1}^{b(i,j,i+1)} \cdots g_n^{b(i,j,n)} 
   \hbox{ for } 1 \leq i \< j \leq n \hbox{ with } j \not \in I$$
$$ g_i g_j g_i^{-1} = g_{i+1}^{c(i,j,i+1)} \cdots g_n^{c(i,j,n)} 
   \hbox{ for } 1 \leq i \< j \leq n \hbox{ with } i \not \in I$$
$$ g_i g_j^{-1} g_i^{-1} = g_{i+1}^{d(i,j,i+1)} \cdots g_n^{d(i,j,n)} 
   \hbox{ for } 1 \leq i \< j \leq n \hbox{ with } i, j, \not \in I$$

Here the right hand sides are assumed to be words in normal
form; that is, for $k \in I$ we have for all exponents 
$0 \leq a(i,j,k), b(i,j,k), c(i,j,k), d(i,j,k) \< r_k$.

A finite presentation of this type is called a *power-conjugate
presentation* and a *pc group* is a polycyclic group defined
by a power-conjugate presentation. Instead of conjugates we could
just as well work with commutators and then the presentation would
be called a *power-commutator* presentation. Both types of presentation
are abriviated as *pc presentation*. Note that a pc presentation is a 
rewriting system.

Clearly, whenever a group $G$ with pcgs $P$ is given, then we can
write down the corresponding pc presentation. On the other hand,
one may just write down a presentation on $n$ abstract generators
$g_1, \ldots, g_n$ with relations of the above form and define a 
group $H$ by this. Then the subgroups $C_i = \langle g_i, \ldots, g_n 
\rangle$ of $H$ form a subnormal series whose factors are cyclic
or trivial. In the case that all factors are non-trivial, we say
that the pc presentation of $H$ is *confluent*. Note that GAP 4
can only work correctly with pc groups defined by a confluent pc 
presentation.
 
At the current level of implementation GAP can only deal with
finite pc groups. This will be extended in near future.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The family pcgs}

Clearly, the generators of a power-conjugate presentation of
a pc group $G$ form a pcgs of the pc group. This pcgs is called
the *family pcgs*.

\Declaration{FamilyPcgs}
\Declaration{IsFamilyPcgs}
\Declaration{InducedPcgsWrtFamilyPcgs}

In GAP 3 the family pcgs has been the only pcgs allowed for a
pc group. Note that this has changed in GAP 4 where a pc group
may have several independent polycyclic generating sequences.
However, the elementary operations for a non-family pcgs may 
not be as efficient as the elementary operations for the family
pcgs. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements of pc groups}

The elements of a pc group $G$ are always represented as words
in normal form with respect to the family pcgs of $G$. 
Thus it is straightforward to compare elements of pc group,
since this boils down to a mere comparison of exponent vectors
with respect to the family pcgs. In particular, the word problem
is efficiently solvable in pc groups.

\>`<pcword>=<pcword>'{equality!pcwords}
\>`<pcword>\<<pcword>'{smaller!pcwords}

However, multiplication and inversion of elements in pc groups
is not as straightforward as in arbitrary finitely presented groups
where a simple concatenation or reversion of the corresponding
words is sufficient (but does not allow to solve the word problem). 
To multiply to elements in a pc group, we
first concatenate the corresponding words and then use an algorithm
called `collection' to transform the new word into a word in normal
form.

\beginexample
gap> g := FamilyPcgs( SmallGroup( 24, 12 ) );
[ f1, f2, f3, f4 ]
gap> g[4] * g[1];
f1*f3
gap> (g[2] * g[3])^-1;
f2^2*f3*f4
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Pc groups versus fp groups}

In theory pc groups are finitely presented groups.  In practice the 
arithmetic in pc groups is different from the arithmetic in fp 
groups. Thus for technical reasons the pc groups in GAP do not form 
a subcategory of the fp groups and hence the methods for fp groups 
cannot be applied to pc groups in general.

\Declaration{IsPcGroup}

\beginexample
gap> G := SmallGroup( 24, 12 );
<pc group with 4 generators>
gap> IsPcGroup( G );
true
gap> IsFpGroup( G );
false
\endexample

Note that it is possible to convert a pc group to a fp group in GAP.

\> IsomorphismFpGroupByPcgs( <pcgs>, <str> )

\beginexample
gap> p := FamilyPcgs( SmallGroup( 24, 12 ) );
[ f1, f2, f3, f4 ]
gap> iso := IsomorphismFpGroupByPcgs( p, "g" );
[ f1, f2, f3, f4 ] -> [ g1, g2, g3, g4 ]
gap> F := Image( iso );
<fp group on the generators [ g1, g2, g3, g4 ]>
gap> RelatorsOfFpGroup( F );
[ g1^2, g2^-1*g1^-1*g2*g1*g2^-1, g3^-1*g1^-1*g3*g1*g4^-1*g3^-1, 
  g4^-1*g1^-1*g4*g1*g4^-1*g3^-1, g2^3, g3^-1*g2^-1*g3*g2*g4^-1*g3^-1, 
  g4^-1*g2^-1*g4*g2*g3^-1, g3^2, g4^-1*g3^-1*g4*g3, g4^2 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Pc Groups}

If necessary, you can supply GAP with a pc presentation
by hand. (Although this is the most tedious way to input a pc group.)
Note that the pc presentation has to be confluent in order to
work with the pc group in GAP.

One way is to define a finitely presented group with a 
pc presentation in GAP and then convert this presentation
into a pc group. Note that this does not work for arbitrary presentations
of polycyclic groups, see Chapter "Quotient Methods" for further information.

\Declaration{PcGroupFpGroup}

\beginexample
gap> F := FreeGroup("a","b","c","d");;
gap> a := F.1;; b := F.2;; c := F.3;; d := F.4;;         
gap> rels := [a^2, b^3, c^2, d^2, Comm(b,a)/b, Comm(c,a)/d, Comm(d,a),
>             Comm(c,b)/(c*d), Comm(d,b)/c, Comm(d,c)];
[ a^2, b^3, c^2, d^2, b^-1*a^-1*b*a*b^-1, c^-1*a^-1*c*a*d^-1, d^-1*a^-1*d*a, 
  c^-1*b^-1*c*b*d^-1*c^-1, d^-1*b^-1*d*b*c^-1, d^-1*c^-1*d*c ]
gap> G := F / rels; 
<fp group on the generators [a,b,c,d]>
gap> H := PcGroupFpGroup( G );
<pc group with 4 generators>
\endexample

Equivalently to the above method one can initiate a collector of
a pc group by hand and convert it into a pc group. In GAP there
are different collectors for different collecting strategies; at
the moment, there are two collectors to choose from: the single
collector for finite pc groups and the combinatorial collector
for finite $p$-groups. See \cite{Sims94} for further information
on collecting strategies.

To initiate a collector one needs to define the underlying free
group to the pc presentated group and the relative orders of the
pc series. 

\>SingleCollector( <fgrp>, <relorders> )
\>CombinatorialCollector( <fgrp>, <relorders> )

Then the right hand sides of the pc presentation have to be declared.
Let $f_1, \ldots, f_n$ be the generators of the underlying free group
<fgrp>. 

\> SetConjugate( <coll>, <i>, <j>, <w> )

set the conjugate $f_j^{f_i}$ to equal <w> where <w> is a word
in $f_{i+1}, \ldots, f_n$ and $i\<j$.

\> SetCommutator( <coll>, <i>, <j>, <w> )

set the commutator of $f_j$ and $f_i$ to equal <w> where <w> is a word
in $f_{i+1}, \ldots, f_n$ and $i\<j$.

\> SetPower( <coll>, <i>, <w> )

set the power $f_i^{r_i}$ to equal <w> where <w> is a word
in $f_{i+1}, \ldots, f_n$.

Finally, the collector has to be converted to a group.

\> GroupByRws( <coll> )
\> GroupByRwsNC( <coll> )

creates a group from a rewriting system. In the first version it
is checked whether the rewriting system is confluent, in the second
version this is assumed to be true.

\beginexample
gap> F := FreeGroup( 2 );;
gap> coll := SingleCollector( F, [2,3] );
<<single collector, 8 Bits>>
gap> SetConjugate( coll, 2, 1, F.2 );  
gap> SetPower( coll, 1, F.2 );
gap> G1 := GroupByRws( coll );
<pc group with 2 generators>
gap> Size(G1); IsAbelian(G1);
6
true
gap> coll := SingleCollector( F, [2,3] );
<<single collector, 8 Bits>>
gap> SetConjugate( coll, 2, 1, F.2^2 );
gap> G2 := GroupByRws( coll );
<pc group with 2 generators>
gap> Size(G2); IsAbelian(G2); 
6
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Computing Pc Groups}

Another possibility to get a pc group in GAP is to convert a 
polycyclic group given by some other representation to a pc group.
For finitely presented groups there are various quotient methods 
available. For all other types of groups we use the following procedures.

\Declaration{GroupByPcgs}

returns a pc group with family pcgs corresponding to <pcgs>.

\beginexample
gap> G := Group( (1,2,3), (3,4,1) );;
gap> GroupByPcgs( Pcgs(G) );
<pc group with 3 generators>
\endexample

\Declaration{IsomorphismPcGroup}

returns an isomorphism to a pc group. 

\beginexample
gap> G := Group( (1,2,3), (3,4,1) );;
gap> iso := IsomorphismPcGroup( G );
Pcgs([ (2,4,3), (1,2)(3,4), (1,3)(2,4) ]) -> [ f1, f2, f3 ]
gap> H := Image( iso );
<pc group with 3 generators>
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Saving a Pc Group}

As printing a polycyclic group does not display the presentation, 
one cannot simply print a pc group to a file to save it. For this
purpose we need the following function.

\Declaration{GapInputPcGroup}

\beginexample
gap> G := SmallGroup( 24, 12 );
<pc group with 4 generators>
gap> PrintTo( "save", GapInputPcGroup( G, "H" ) );
gap> Read( "save" );
#I A group of order 24 has been defined.
#I It is called H
gap> H = G;
false
gap> IdGroup( H ) = IdGroup( G );
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations for Pc Groups}

Clearly, all operations described in Chapters "Groups" and "Polycyclic 
Groups" apply to a pc group. Moreover, there is a method to compute
intersections of subgroups of a pc group.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{2-Cohomology and Extensions}

One of the most interesting applications of pc groups is the possibility
to compute with extensions of these groups by elementary abelian groups;
that is, $H$ is an extension of $G$ by $M$, if there exists a normal 
subgroup $N$ in $H$ which is isomorphic to $M$ such that $H/N$ is
isomorphic to $G$.

Pc groups are particularly suited for such applications, since the
2-cohomomology can be computed efficiently for such groups and,
moreover, extensions of pc groups by elementary abelian groups can
be represented by pc groups again.

To define the elementary abelian group $M$ together with an action
of $G$ on $M$ we consider $M$ as a module for $G$ over a finite
field.

\Declaration{TwoCoboundaries}
\Declaration{TwoCocycles}
\Declaration{TwoCohomology}

\beginexample
gap> G := SmallGroup( 4, 2 ); 
<pc group of size 4 with 2 generators> 
gap> mats := List( Pcgs( G ), x -> IdentityMat( 1, GF(2) ) );
[ [ <a GF2 vector of length 1> ], [ <a GF2 vector of length 1> ] ]
gap> M := GModuleByMats( mats, GF(2) );
rec( field := GF(2), isMTXModule := true, dimension := 1, 
  generators := [ [ <a GF2 vector of length 1> ], 
      [ <a GF2 vector of length 1> ] ] )
gap> TwoCoboundaries( G, M );
[  ]
gap> TwoCocycles( G, M );                                    
[ [ Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0 ] ]
gap> cc := TwoCohomology( G, M );;
gap> cc.cohom;
<linear mapping by matrix, VectorSpace( GF(2), 
[ [ Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0 ] ] ) -> ( GF(2)^3 )>
\endexample

\Declaration{Extensions}
\Declaration{Extension}
\Declaration{SplitExtension}

\beginexample
gap> G := SmallGroup( 4, 2 );;
gap> mats := List( Pcgs( G ), x -> IdentityMat( 1, GF(2) ) );;
gap> M := GModuleByMats( mats, GF(2) );;
gap> co := TwoCocycles( G, M );;
gap> Extension( G, M, co[2] );
<pc group with 3 generators>
gap> SplitExtension( G, M );
<pc group with 3 generators>
gap> Extensions( G, M );
[ <pc group with 3 generators>, <pc group with 3 generators>, 
  <pc group with 3 generators>, <pc group with 3 generators>, 
  <pc group with 3 generators>, <pc group with 3 generators>, 
  <pc group with 3 generators>, <pc group with 3 generators> ]
\endexample

\beginexample
gap> N := SmallGroup( 8, 4 );
<pc group with 3 generators>
gap> IsAbelian( N );
false
gap> A := AutomorphismGroup( N );
<group of size 24 with 4 generators>
gap> iso := IsomorphismPcGroup( A );
CompositionMapping( Pcgs([ (1,6,4,3), (1,2,6)(3,4,5), (1,4)(3,6), (2,5)(3,6) 
 ]) -> [ f1, f2, f3, f4 ], <operation homomorphism> )
gap> H := Image( iso );
<pc group with 4 generators>
gap> G := Subgroup( H, Pcgs(H){[1,2]} );
Group([ f1, f2 ])
gap> inv := InverseGeneralMapping( iso );
InverseGeneralMapping( CompositionMapping( Pcgs(
[ (1,6,4,3), (1,2,6)(3,4,5), (1,4)(3,6), (2,5)(3,6) ]) -> [ f1, f2, f3, f4 
 ], <operation homomorphism> ) )
gap> K := SplitExtension( G, inv, N );
<pc group with 7 generators>
gap> Size(K);
192
\endexample

There exists an action of the subgroup of *compatible pairs* in
$Aut(G) \times Aut(M)$ which acts on the second cohomology group.
2-cocycles which ly in the same orbit under this action define
isomorphic extensions of $G$. However, there may be isomophic 
extensions of $G$ corresponding to cocycles in different orbits.

\Declaration{CompatiblePairs}
\Declaration{ExtensionRepresentatives}

\beginexample
gap> G := SmallGroup( 4, 2 );;
gap> mats := List( Pcgs( G ), x -> IdentityMat( 1, GF(2) ) );;
gap> M := GModuleByMats( mats, GF(2) );;
gap> A := AutomorphismGroup( G );;
gap> B := GL( 1, 2 );;
gap> D := DirectProduct( A, B );
<group with 6 generators>
gap> P := CompatiblePairs( G, M, D );
<group of size 6 with 3 generators>
gap> ExtensionRepresentatives( G, M, P );
[ <pc group with 3 generators>, <pc group with 3 generators>, 
  <pc group with 3 generators>, <pc group with 3 generators> ]
gap> Extensions( G, M );
[ <pc group with 3 generators>, <pc group with 3 generators>, 
  <pc group with 3 generators>, <pc group with 3 generators>, 
  <pc group with 3 generators>, <pc group with 3 generators>, 
  <pc group with 3 generators>, <pc group with 3 generators> ]
\endexample

See also the forthcoming share package `Group Construction Methods'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Coding a Pc Presentation}

If one wants to store a large number of pc groups, then it can be useful
to store them in a compressed format, since pc presentations can be 
space consuming. Here we introduce a method to code and decode pc 
presentations by integers. To decode a given code the size of the 
underlying pc group is needed as well. For the full definition and 
the coding and decoding 
procedures see \cite{BescheEick98}. This method is used with the small 
groups library, see Section "Small Groups".

\Declaration{CodePcgs}
\Declaration{CodePcGroup}
\Declaration{PcGroupCode}
\Declaration{PcGroupCodeRec}

\beginexample
gap> G := SmallGroup( 24, 12 );;
gap> p := Pcgs( G );;
gap> code := CodePcgs( p );
5790338948
gap> H := PcGroupCode( code, 24 );
<pc group with 4 generators>
gap> map := GroupHomomorphismByImages( G, H, p, FamilyPcgs(H) );
Pcgs([ f1, f2, f3, f4 ]) -> Pcgs([ f1, f2, f3, f4 ])
gap> IsBijective(map);
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Random Isomorphism Testing}

The generic isomorphism test for groups may be applied to pc groups
as well. However, this test is often quite time consuming. Here we
describe another method to test isomorphism by a probabilistic approach.

This method takes a list of groups and a non-negative integer as
input. The output is a sublist of the input list where only isomorphic 
copies have been removed. The integer gives a certain amount of control
over the probability to detect all isomorphisms. 
If it is 0, then nothing will be done at all. The larger the integer is,
the larger is the probablity of finding all isomorphisms. However, the 
probability cannot reach 1.

\Declaration{RandomIsomorphismTest}

